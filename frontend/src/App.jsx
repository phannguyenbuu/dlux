import React, { useMemo, useRef, useState, useEffect } from "react";
import { jsPDF } from "jspdf";
import { svg2pdf } from "svg2pdf.js";
import Konva from "konva";
import { Stage, Layer, Line, Text, Circle, Rect, Path, Group, Image, Transformer } from "react-konva";

const toPoints = (pts) => pts.flatMap((p) => [p[0], p[1]]);

const measureText = (text, fontSize, fontFamily) => {
  const size = Number.isFinite(fontSize) ? fontSize : 12;
  const family = fontFamily || "Arial";
  if (Konva?.Util?.getTextWidth) {
    const width = Konva.Util.getTextWidth(text || "", size, family);
    return { width, height: size };
  }
  const width = (text ? text.length : 0) * size * 0.6;
  return { width, height: size };
};
const rotatePt = (pt, angleDeg, cx, cy) => {
  if (!angleDeg) return pt;
  const ang = (angleDeg * Math.PI) / 180;
  const c = Math.cos(ang);
  const s = Math.sin(ang);
  const x = pt[0] - cx;
  const y = pt[1] - cy;
  return [cx + x * c - y * s, cy + x * s + y * c];
};

const transformPath = (pts, shift, rot, center) => {
  if (!pts || !pts.length) return [];
  const dx = shift?.[0] ?? 0;
  const dy = shift?.[1] ?? 0;
  const ang = rot ?? 0;
  const cx = center?.[0] ?? 0;
  const cy = center?.[1] ?? 0;
  return pts.map((p) => {
    const r = rotatePt(p, ang, cx, cy);
    return [r[0] + dx, r[1] + dy];
  });
};

const bboxFromPts = (pts) => {
  if (!pts || !pts.length) return null;
  let minx = pts[0][0];
  let maxx = pts[0][0];
  let miny = pts[0][1];
  let maxy = pts[0][1];
  for (let i = 1; i < pts.length; i++) {
    const x = pts[i][0];
    const y = pts[i][1];
    if (x < minx) minx = x;
    if (x > maxx) maxx = x;
    if (y < miny) miny = y;
    if (y > maxy) maxy = y;
  }
  return { minx, maxx, miny, maxy };
};

const pointInPoly = (pt, poly) => {
  let inside = false;
  for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
    const xi = poly[i][0];
    const yi = poly[i][1];
    const xj = poly[j][0];
    const yj = poly[j][1];
    const intersect = yi > pt[1] !== yj > pt[1] &&
      pt[0] < ((xj - xi) * (pt[1] - yi)) / (yj - yi + 0.0) + xi;
    if (intersect) inside = !inside;
  }
  return inside;
};

const pointSegDist = (pt, a, b) => {
  const vx = b[0] - a[0];
  const vy = b[1] - a[1];
  const wx = pt[0] - a[0];
  const wy = pt[1] - a[1];
  const c1 = vx * wx + vy * wy;
  if (c1 <= 0) return Math.hypot(pt[0] - a[0], pt[1] - a[1]);
  const c2 = vx * vx + vy * vy;
  if (c2 <= c1) return Math.hypot(pt[0] - b[0], pt[1] - b[1]);
  const t = c1 / c2;
  const px = a[0] + t * vx;
  const py = a[1] + t * vy;
  return Math.hypot(pt[0] - px, pt[1] - py);
};

const pointInPolyWithOffset = (pt, poly, offset) => {
  if (pointInPoly(pt, poly)) return true;
  for (let i = 0; i < poly.length; i++) {
    const a = poly[i];
    const b = poly[(i + 1) % poly.length];
    if (pointSegDist(pt, a, b) <= offset) return true;
  }
  return false;
};

const buildPackedPolyData = (data) => {
  if (!data?.regions || !data?.zone_id) return [];
  return data.regions.map((poly, rid) => {
    const zid = data.zone_id[rid];
    const shift = data.zone_shift?.[zid] || data.zone_shift?.[parseInt(zid, 10)];
    const rot = data.zone_rot?.[zid] ?? data.zone_rot?.[parseInt(zid, 10)] ?? 0;
    const center = data.zone_center?.[zid] || data.zone_center?.[parseInt(zid, 10)] || [0, 0];
    const tpts = shift ? transformPath(poly, shift, rot, center) : poly;
    return { pts: tpts, bbox: bboxFromPts(tpts) };
  });
};

const buildPackedZonePolyData = (data) => {
  if (!data?.zone_pack_polys || !data?.zone_order) return [];
  const out = [];
  data.zone_order.forEach((zid, idx) => {
    const poly = data.zone_pack_polys?.[idx];
    if (!poly || !poly.length) return;
    const shift = data.zone_shift?.[zid] || data.zone_shift?.[parseInt(zid, 10)];
    const rot = data.zone_rot?.[zid] ?? data.zone_rot?.[parseInt(zid, 10)] ?? 0;
    const center = data.zone_center?.[zid] || data.zone_center?.[parseInt(zid, 10)] || [0, 0];
    const tpts = shift ? transformPath(poly, shift, rot, center) : poly;
    out.push({ pts: tpts, bbox: bboxFromPts(tpts) });
  });
  return out;
};

const buildPackedEmptyCells = (data, packedPolyData) => {
  if (!data?.canvas || !packedPolyData?.length) return [];
  const cellSize = 6;
  const radius = 3;
  const pts = [];
  const w = data.canvas.w;
  const h = data.canvas.h;
  for (let y = cellSize; y + cellSize <= h; y += cellSize) {
    for (let x = cellSize; x + cellSize <= w; x += cellSize) {
      const cx = x + radius;
      const cy = y + radius;
      if (cx < radius || cy < radius || cx > w - radius || cy > h - radius) continue;
      const corners = [
        [x, y],
        [x + cellSize, y],
        [x + cellSize, y + cellSize],
        [x, y + cellSize],
        [cx, cy],
      ];
      let inside = false;
      for (const poly of packedPolyData) {
        const bb = poly.bbox;
        if (!bb) continue;
        const minx = bb.minx - radius;
        const maxx = bb.maxx + radius;
        const miny = bb.miny - radius;
        const maxy = bb.maxy + radius;
        if (x > maxx || x + cellSize < minx || y > maxy || y + cellSize < miny) continue;
        for (const pt of corners) {
          if (pointInPolyWithOffset(pt, poly.pts, radius)) {
            inside = true;
            break;
          }
        }
        if (inside) break;
      }
      if (!inside) pts.push([cx, cy]);
    }
  }
  return pts;
};

const scalePts = (pts, ratio) => (pts || []).map((p) => [p[0] * ratio, p[1] * ratio]);

const scaleSegments = (segments, ratio) =>
  (segments || []).map((seg) => scalePts(seg, ratio));

const scaleSceneData = (scene, ratio) => {
  if (!scene || ratio === 1) return scene;
  const scaleNum = (v) => (Number.isFinite(v) ? v * ratio : v);
  const scalePolyList = (polys) => (polys || []).map((poly) => scalePts(poly || [], ratio));
  const scaleLineDict = (dict) => {
    const out = {};
    Object.entries(dict || {}).forEach(([k, paths]) => {
      out[k] = (paths || []).map((path) => scalePts(path || [], ratio));
    });
    return out;
  };
  const scaleLabelDict = (dict) => {
    const out = {};
    Object.entries(dict || {}).forEach(([k, v]) => {
      if (!v) return;
      out[k] = { ...v, x: scaleNum(v.x), y: scaleNum(v.y) };
    });
    return out;
  };
  const scaleShiftDict = (dict) => {
    const out = {};
    Object.entries(dict || {}).forEach(([k, v]) => {
      if (!Array.isArray(v) || v.length < 2) return;
      out[k] = [scaleNum(v[0]), scaleNum(v[1])];
    });
    return out;
  };
  const scalePlacements = (placements) =>
    (placements || []).map((p) =>
      Array.isArray(p) && p.length >= 4
        ? [scaleNum(p[0]), scaleNum(p[1]), scaleNum(p[2]), scaleNum(p[3]), p[4]]
        : p
    );
  const scaleRotInfo = (rotInfo) =>
    (rotInfo || []).map((info) => {
      if (!info || typeof info !== "object") return info;
      const out = { ...info };
      ["cx", "cy", "minx", "miny", "maxx", "maxy"].forEach((k) => {
        if (Number.isFinite(out[k])) out[k] = out[k] * ratio;
      });
      return out;
    });

  return {
    ...scene,
    canvas: scene.canvas ? { ...scene.canvas } : scene.canvas,
    regions: scalePolyList(scene.regions),
    zone_boundaries: scaleLineDict(scene.zone_boundaries),
    zone_labels: scaleLabelDict(scene.zone_labels),
    region_labels: scaleLabelDict(scene.region_labels),
    zone_pack_polys: scalePolyList(scene.zone_pack_polys),
    placements: scalePlacements(scene.placements),
    rot_info: scaleRotInfo(scene.rot_info),
    zone_shift: scaleShiftDict(scene.zone_shift),
    zone_center: scaleShiftDict(scene.zone_center),
  };
};

const logPackedPreview = (data) => {
  if (!data) return;
  const placements = data.placements || [];
  const binW = data.canvas?.w || 0;
  const binH = data.canvas?.h || 0;
  let placed = 0;
  let unplaced = 0;
  let placedArea = 0;
  const unplacedIds = [];
  const pageCounts = {};
  placements.forEach((p, idx) => {
    const dx = p?.[0] ?? -1;
    const dy = p?.[1] ?? -1;
    const bw = p?.[2] ?? 0;
    const bh = p?.[3] ?? 0;
    if (dx < 0 || dy < 0 || bw <= 0 || bh <= 0) {
      unplaced += 1;
      unplacedIds.push(idx);
    } else {
      placed += 1;
      placedArea += bw * bh;
    }
    const bin = data.placement_bin?.[idx];
    if (bin != null) {
      pageCounts[bin] = (pageCounts[bin] || 0) + 1;
    }
  });
  const binArea = binW * binH;
  const fillRatio = binArea ? placedArea / binArea : 0;
  const debug = data.debug || {};
  console.groupCollapsed(
    `[packed preview] placed=${placed} unplaced=${unplaced} area=${placedArea}/${binArea} (${(fillRatio * 100).toFixed(
      2
    )}%)`
  );
  console.log("canvas", data.canvas);
  console.log("placed/unplaced", { placed, unplaced, placedArea, binArea, fillRatio });
  console.log("unplaced_ids", unplacedIds);
  console.log("page_counts", pageCounts);
  console.log("debug", debug);
  console.log("pack_settings", {
    packPadding: data.pack_padding,
    packMarginX: data.pack_margin_x,
    packMarginY: data.pack_margin_y,
    packGrid: data.pack_grid,
    packAngle: data.pack_angle,
    packMode: data.pack_mode,
    drawScale: data.draw_scale,
  });
  console.groupEnd();
};

// packed zone boundaries are transformed on backend

const parsePoints = (str) => {
  if (!str) return [];
  const raw = str
    .trim()
    .replace(/\s+/g, " ")
    .split(" ")
    .flatMap((p) => p.split(","))
    .map((v) => v.trim())
    .filter(Boolean);
  const pts = [];
  for (let i = 0; i + 1 < raw.length; i += 2) {
    const x = parseFloat(raw[i]);
    const y = parseFloat(raw[i + 1]);
    if (Number.isFinite(x) && Number.isFinite(y)) pts.push([x, y]);
  }
  return pts;
};

const parseSvgSize = (svgText) => {
  const doc = new DOMParser().parseFromString(svgText, "image/svg+xml");
  const svg = doc.querySelector("svg");
  if (!svg) return { w: 1000, h: 1000 };
  const vb = svg.getAttribute("viewBox");
  if (vb) {
    const parts = vb.replace(/,/g, " ").trim().split(/\s+/).map(parseFloat);
    if (parts.length === 4 && parts.every(Number.isFinite)) {
      return { w: parts[2], h: parts[3] };
    }
  }
  const w = parseFloat(svg.getAttribute("width") || "1000");
  const h = parseFloat(svg.getAttribute("height") || "1000");
  return {
    w: Number.isFinite(w) ? w : 1000,
    h: Number.isFinite(h) ? h : 1000,
  };
};

const getSvgHref = (el) =>
  el.getAttribute("href") || el.getAttribute("xlink:href") || el.getAttribute("href.baseVal") || "";

const svgToDataUrl = (svgText) =>
  `data:image/svg+xml;charset=utf-8,${encodeURIComponent(svgText)}`;

const decodeSvgDataUrl = (src) => {
  if (!src || !src.startsWith("data:image/svg+xml")) return null;
  const parts = src.split(",");
  if (parts.length < 2) return null;
  try {
    return decodeURIComponent(parts.slice(1).join(","));
  } catch {
    return null;
  }
};

const applySvgFill = (svgText, color) => {
  if (!svgText) return svgText;
  try {
    const doc = new DOMParser().parseFromString(svgText, "image/svg+xml");
    const tags = ["path", "rect", "circle", "ellipse", "polygon", "polyline"];
    tags.forEach((tag) => {
      doc.querySelectorAll(tag).forEach((el) => {
        const fill = el.getAttribute("fill");
        if (fill && fill.toLowerCase() === "none") return;
        el.setAttribute("fill", color);
      });
    });
    return new XMLSerializer().serializeToString(doc);
  } catch {
    return svgText;
  }
};

const parseOverlayItems = (svgText) => {
  if (!svgText) return [];
  try {
    const doc = new DOMParser().parseFromString(svgText, "image/svg+xml");
    const nodes = Array.from(
      doc.querySelectorAll("g#OVERLAY image[data-overlay='1'], image[data-overlay='1']")
    );
    return nodes.map((node, idx) => {
      const src = getSvgHref(node);
      const x = parseFloat(node.getAttribute("data-x") || node.getAttribute("x") || "0");
      const y = parseFloat(node.getAttribute("data-y") || node.getAttribute("y") || "0");
      const width = parseFloat(node.getAttribute("data-width") || node.getAttribute("width") || "0");
      const height = parseFloat(
        node.getAttribute("data-height") || node.getAttribute("height") || "0"
      );
      const scaleX = parseFloat(node.getAttribute("data-scale-x") || "1");
      const scaleY = parseFloat(node.getAttribute("data-scale-y") || "1");
      const rotation = parseFloat(node.getAttribute("data-rotation") || "0");
      return {
        id: node.getAttribute("data-id") || `overlay-${idx}`,
        src,
        x,
        y,
        width,
        height,
        scaleX: Number.isFinite(scaleX) ? scaleX : 1,
        scaleY: Number.isFinite(scaleY) ? scaleY : 1,
        rotation: Number.isFinite(rotation) ? rotation : 0,
      };
    });
  } catch {
    return [];
  }
};

const loadImageFromSrc = (src) =>
  new Promise((resolve) => {
    if (!src) {
      resolve(null);
      return;
    }
    const img = new window.Image();
    img.onload = () => resolve(img);
    img.onerror = () => resolve(null);
    img.src = src;
  });

const buildSegmentsFromSvg = (svgText) => {
  const doc = new DOMParser().parseFromString(svgText, "image/svg+xml");
  const segments = [];
  const borderSegments = [];
  const svgSize = parseSvgSize(svgText);
  const isOuterBorder = (pts) => {
    if (!pts || pts.length < 4) return false;
    const xs = pts.map((p) => p[0]);
    const ys = pts.map((p) => p[1]);
    const minx = Math.min(...xs);
    const maxx = Math.max(...xs);
    const miny = Math.min(...ys);
    const maxy = Math.max(...ys);
    const tol = 1.0;
    return (
      Math.abs(minx - 0) < tol ||
      Math.abs(miny - 0) < tol ||
      Math.abs(maxx - svgSize.w) < tol ||
      Math.abs(maxy - svgSize.h) < tol
    );
  };
  doc.querySelectorAll("line").forEach((el) => {
    const x1 = parseFloat(el.getAttribute("x1") || "0");
    const y1 = parseFloat(el.getAttribute("y1") || "0");
    const x2 = parseFloat(el.getAttribute("x2") || "0");
    const y2 = parseFloat(el.getAttribute("y2") || "0");
    segments.push([[x1, y1], [x2, y2]]);
  });
  doc.querySelectorAll("polyline").forEach((el) => {
    const pts = parsePoints(el.getAttribute("points"));
    const isBorder = isOuterBorder(pts);
    for (let i = 0; i + 1 < pts.length; i++) {
      const seg = [pts[i], pts[i + 1]];
      segments.push(seg);
      if (isBorder) borderSegments.push(seg);
    }
  });
  doc.querySelectorAll("polygon").forEach((el) => {
    const pts = parsePoints(el.getAttribute("points"));
    const isBorder = isOuterBorder(pts);
    for (let i = 0; i + 1 < pts.length; i++) {
      const seg = [pts[i], pts[i + 1]];
      segments.push(seg);
      if (isBorder) borderSegments.push(seg);
    }
    if (pts.length > 2) {
      const seg = [pts[pts.length - 1], pts[0]];
      segments.push(seg);
      if (isBorder) borderSegments.push(seg);
    }
  });
  return { segments, borderSegments };
};

const snapNodes = (segments, snap) => {
  const cells = new Map();
  const nodes = [];
  const nodeSum = [];
  const nodeCnt = [];

  const cellKey = (x, y) => `${Math.floor(x / snap)},${Math.floor(y / snap)}`;

  const findOrCreate = (pt) => {
    const [x, y] = pt;
    if (!snap || snap <= 0) {
      const id = nodes.length;
      nodes.push({ id, x, y });
      return id;
    }
    const cx = Math.floor(x / snap);
    const cy = Math.floor(y / snap);
    let found = -1;
    for (let dx = -1; dx <= 1; dx++) {
      for (let dy = -1; dy <= 1; dy++) {
        const key = `${cx + dx},${cy + dy}`;
        const ids = cells.get(key);
        if (!ids) continue;
        for (const id of ids) {
          const nx = nodes[id].x;
          const ny = nodes[id].y;
          const d2 = (nx - x) * (nx - x) + (ny - y) * (ny - y);
          if (d2 <= snap * snap) {
            found = id;
            break;
          }
        }
        if (found !== -1) break;
      }
      if (found !== -1) break;
    }
    if (found === -1) {
      const id = nodes.length;
      nodes.push({ id, x, y });
      const key = cellKey(x, y);
      if (!cells.has(key)) cells.set(key, []);
      cells.get(key).push(id);
      nodeSum[id] = [x, y];
      nodeCnt[id] = 1;
      return id;
    }
    nodeSum[found][0] += x;
    nodeSum[found][1] += y;
    nodeCnt[found] += 1;
    return found;
  };

  const segs = segments.map(([a, b]) => {
    const ai = findOrCreate(a);
    const bi = findOrCreate(b);
    return [ai, bi];
  });

  // recompute centroid positions
  nodes.forEach((n, i) => {
    if (nodeCnt[i]) {
      n.x = nodeSum[i][0] / nodeCnt[i];
      n.y = nodeSum[i][1] / nodeCnt[i];
    }
  });

  return { nodes, segs };
};

const calcBounds = (polys) => {
  if (!polys || polys.length === 0) return { minx: 0, miny: 0, maxx: 1, maxy: 1 };
  let minx = Infinity;
  let miny = Infinity;
  let maxx = -Infinity;
  let maxy = -Infinity;
  polys.forEach((poly) => {
    poly.forEach((p) => {
      minx = Math.min(minx, p[0]);
      miny = Math.min(miny, p[1]);
      maxx = Math.max(maxx, p[0]);
      maxy = Math.max(maxy, p[1]);
    });
  });
  return { minx, miny, maxx, maxy };
};

const calcBoundsFromLines = (linesDict) => {
  if (!linesDict) return { minx: 0, miny: 0, maxx: 1, maxy: 1 };
  let minx = Infinity;
  let miny = Infinity;
  let maxx = -Infinity;
  let maxy = -Infinity;
  let found = false;
  Object.values(linesDict).forEach((lines) => {
    (lines || []).forEach((pts) => {
      pts.forEach((p) => {
        found = true;
        minx = Math.min(minx, p[0]);
        miny = Math.min(miny, p[1]);
        maxx = Math.max(maxx, p[0]);
        maxy = Math.max(maxy, p[1]);
      });
    });
  });
  if (!found) return { minx: 0, miny: 0, maxx: 1, maxy: 1 };
  return { minx, miny, maxx, maxy };
};

const mergeNodesIfClose = (nodes, segs, movedId, snap) => {
  if (!snap || snap <= 0) return { nodes, segs };
  const moved = nodes.find((n) => n.id === movedId);
  if (!moved) return { nodes, segs };
  let targetId = null;
  for (const n of nodes) {
    if (n.id === movedId) continue;
    const dx = n.x - moved.x;
    const dy = n.y - moved.y;
    if (dx * dx + dy * dy <= snap * snap) {
      targetId = n.id;
      break;
    }
  }
  if (targetId == null) return { nodes, segs };

  const merged = nodes
    .filter((n) => n.id !== movedId)
    .map((n) =>
      n.id === targetId
        ? { ...n, x: (n.x + moved.x) / 2, y: (n.y + moved.y) / 2 }
        : n
    );

  const remap = new Map();
  merged.forEach((n, idx) => {
    remap.set(n.id, idx);
  });
  const newSegs = segs
    .map(([a, b]) => {
      const na = a === movedId ? targetId : a;
      const nb = b === movedId ? targetId : b;
      if (na === nb) return null;
      return [remap.get(na), remap.get(nb)];
    })
    .filter(Boolean);

  const newNodes = merged.map((n, idx) => ({ ...n, id: idx }));
  return { nodes: newNodes, segs: newSegs };
};

const segmentIntersect = (a1, a2, b1, b2) => {
  const x1 = a1[0], y1 = a1[1], x2 = a2[0], y2 = a2[1];
  const x3 = b1[0], y3 = b1[1], x4 = b2[0], y4 = b2[1];
  const dx12 = x2 - x1;
  const dy12 = y2 - y1;
  const dx34 = x4 - x3;
  const dy34 = y4 - y3;
  const denom = dy12 * dx34 - dx12 * dy34;
  if (Math.abs(denom) < 1e-9) return null;
  const t = ((x1 - x3) * dy34 + (y3 - y1) * dx34) / denom;
  const u = ((x3 - x1) * dy12 + (y1 - y3) * dx12) / -denom;
  if (t < 0 || t > 1 || u < 0 || u > 1) return null;
  return { x: x1 + dx12 * t, y: y1 + dy12 * t, t, u };
};

const edgeKey = (a, b) => (a < b ? `${a}-${b}` : `${b}-${a}`);

const splitAtIntersections = (segments) => {
  const splits = segments.map(() => [0, 1]);
  for (let i = 0; i < segments.length; i++) {
    for (let j = i + 1; j < segments.length; j++) {
      const a = segments[i];
      const b = segments[j];
      const inter = segmentIntersect(a[0], a[1], b[0], b[1]);
      if (!inter) continue;
      splits[i].push(inter.t);
      splits[j].push(inter.u);
    }
  }
  const out = [];
  for (let i = 0; i < segments.length; i++) {
    const ts = Array.from(new Set(splits[i].map((v) => Math.max(0, Math.min(1, v))))).sort((a, b) => a - b);
    const [a, b] = segments[i];
    const dx = b[0] - a[0];
    const dy = b[1] - a[1];
    for (let k = 0; k < ts.length - 1; k++) {
      const t0 = ts[k];
      const t1 = ts[k + 1];
      if (t1 - t0 < 1e-6) continue;
      const p0 = [a[0] + dx * t0, a[1] + dy * t0];
      const p1 = [a[0] + dx * t1, a[1] + dy * t1];
      out.push([p0, p1]);
    }
  }
  return out;
};

const snapKey = (pt, eps) => {
  if (!eps || eps <= 0) return `${Math.round(pt[0])},${Math.round(pt[1])}`;
  return `${Math.round(pt[0] / eps)},${Math.round(pt[1] / eps)}`;
};

const edgeKeyPts = (a, b) => (a < b ? `${a}|${b}` : `${b}|${a}`);

const buildRegionAdjacency = (polys, eps = 0.5) => {
  const edgeMap = new Map();
  polys.forEach((pts, rid) => {
    if (!pts || pts.length < 2) return;
    for (let i = 0; i < pts.length; i++) {
      const p1 = pts[i];
      const p2 = pts[(i + 1) % pts.length];
      const k1 = snapKey(p1, eps);
      const k2 = snapKey(p2, eps);
      if (k1 === k2) continue;
      const ek = edgeKeyPts(k1, k2);
      if (!edgeMap.has(ek)) edgeMap.set(ek, []);
      edgeMap.get(ek).push(rid);
    }
  });
  const adj = Array.from({ length: polys.length }, () => new Set());
  for (const ids of edgeMap.values()) {
    if (ids.length < 2) continue;
    for (let i = 0; i < ids.length; i++) {
      for (let j = i + 1; j < ids.length; j++) {
        adj[ids[i]].add(ids[j]);
        adj[ids[j]].add(ids[i]);
      }
    }
  }
  return adj.map((s) => Array.from(s));
};

const buildRegionAdjacencyMulti = (polys, epsList) => {
  const merged = Array.from({ length: polys.length }, () => new Set());
  (epsList || []).forEach((eps) => {
    const adj = buildRegionAdjacency(polys, eps);
    adj.forEach((neighbors, rid) => {
      neighbors.forEach((nb) => merged[rid].add(nb));
    });
  });
  return merged.map((s) => Array.from(s));
};

const buildZoneBoundaries = (polys, zoneId, snap = 0) => {
  const zones = new Map();
  polys.forEach((pts, rid) => {
    const zid = zoneId?.[rid] ?? -1;
    if (!zones.has(zid)) zones.set(zid, []);
    zones.get(zid).push(pts);
  });

  const zoneBoundaries = {};
  zones.forEach((zpolys, zid) => {
    const edgeCounts = new Map();
    const pointSum = new Map();

    const addPoint = (k, p) => {
      const entry = pointSum.get(k);
      if (!entry) {
        pointSum.set(k, [p[0], p[1], 1]);
      } else {
        entry[0] += p[0];
        entry[1] += p[1];
        entry[2] += 1;
      }
    };

    zpolys.forEach((pts) => {
      if (!pts || pts.length < 2) return;
      for (let i = 0; i < pts.length; i++) {
        const p1 = pts[i];
        const p2 = pts[(i + 1) % pts.length];
        const k1 = snapKey(p1, snap);
        const k2 = snapKey(p2, snap);
        if (k1 === k2) continue;
        addPoint(k1, p1);
        addPoint(k2, p2);
        const ek = edgeKeyPts(k1, k2);
        const entry = edgeCounts.get(ek);
        if (entry) {
          entry.count += 1;
        } else {
          edgeCounts.set(ek, { count: 1, a: k1, b: k2 });
        }
      }
    });

    const boundaryEdges = [];
    edgeCounts.forEach((entry) => {
      if (entry.count === 1) boundaryEdges.push([entry.a, entry.b]);
    });
    if (!boundaryEdges.length) {
      zoneBoundaries[zid] = [];
      return;
    }

    const pointMap = new Map();
    pointSum.forEach((val, key) => {
      if (val[2] > 0) pointMap.set(key, [val[0] / val[2], val[1] / val[2]]);
    });

    const adj = new Map();
    boundaryEdges.forEach(([k1, k2], idx) => {
      if (!adj.has(k1)) adj.set(k1, []);
      if (!adj.has(k2)) adj.set(k2, []);
      adj.get(k1).push(idx);
      adj.get(k2).push(idx);
    });

    const used = new Array(boundaryEdges.length).fill(false);
    const polylines = [];

    const nextEdge = (curKey, prevKey) => {
      const candidates = (adj.get(curKey) || []).filter((ei) => !used[ei]);
      if (!candidates.length) return null;
      if (!prevKey) return candidates[0];
      const pcur = pointMap.get(curKey);
      const pprev = pointMap.get(prevKey);
      if (!pcur || !pprev) return candidates[0];
      const vx = pcur[0] - pprev[0];
      const vy = pcur[1] - pprev[1];
      const vlen = Math.hypot(vx, vy);
      if (vlen === 0) return candidates[0];
      let best = candidates[0];
      let bestDot = -1e9;
      for (const ei of candidates) {
        const [a, b] = boundaryEdges[ei];
        const nxt = a === curKey ? b : a;
        const pnxt = pointMap.get(nxt);
        if (!pnxt) continue;
        const wx = pnxt[0] - pcur[0];
        const wy = pnxt[1] - pcur[1];
        const wlen = Math.hypot(wx, wy);
        if (wlen === 0) continue;
        const dot = (vx * wx + vy * wy) / (vlen * wlen);
        if (dot > bestDot) {
          bestDot = dot;
          best = ei;
        }
      }
      return best;
    };

    for (let i = 0; i < boundaryEdges.length; i++) {
      if (used[i]) continue;
      used[i] = true;
      const [k1, k2] = boundaryEdges[i];
      const pathKeys = [k1, k2];

      while (true) {
        const cur = pathKeys[pathKeys.length - 1];
        const prev = pathKeys.length >= 2 ? pathKeys[pathKeys.length - 2] : null;
        const ei = nextEdge(cur, prev);
        if (ei == null) break;
        used[ei] = true;
        const [a, b] = boundaryEdges[ei];
        const nxt = a === cur ? b : a;
        if (nxt === pathKeys[pathKeys.length - 1]) break;
        pathKeys.push(nxt);
        if (nxt === pathKeys[0]) break;
      }

      while (true) {
        const cur = pathKeys[0];
        const prev = pathKeys.length >= 2 ? pathKeys[1] : null;
        const ei = nextEdge(cur, prev);
        if (ei == null) break;
        used[ei] = true;
        const [a, b] = boundaryEdges[ei];
        const nxt = a === cur ? b : a;
        if (nxt === pathKeys[0]) break;
        pathKeys.unshift(nxt);
        if (nxt === pathKeys[pathKeys.length - 1]) break;
      }

      const pathPts = pathKeys.map((k) => pointMap.get(k)).filter(Boolean);
      if (pathPts.length >= 2) polylines.push(pathPts);
    }

    zoneBoundaries[zid] = polylines;
  });

  return zoneBoundaries;
};

const polyAreaAndCentroid = (poly) => {
  if (!poly || poly.length < 3) return { area: 0, cx: 0, cy: 0 };
  let area = 0;
  let cx = 0;
  let cy = 0;
  const n = poly.length;
  for (let i = 0; i < n; i++) {
    const [x0, y0] = poly[i];
    const [x1, y1] = poly[(i + 1) % n];
    const cross = x0 * y1 - x1 * y0;
    area += cross;
    cx += (x0 + x1) * cross;
    cy += (y0 + y1) * cross;
  }
  area *= 0.5;
  if (Math.abs(area) < 1e-6) return { area: 0, cx: poly[0][0], cy: poly[0][1] };
  return { area, cx: cx / (6 * area), cy: cy / (6 * area) };
};

export default function App() {
  const [snap, setSnap] = useState(1);
  const [sourceScale, setSourceScale] = useState(1);
  const [targetZones, setTargetZones] = useState(120);
  const [sourceName, setSourceName] = useState("convoi");
  const [sourceFilename, setSourceFilename] = useState("convoi.svg");
  const [recentFiles, setRecentFiles] = useState([]);
  const [scene, setScene] = useState(null);
  const [zoneScene, setZoneScene] = useState(null);
  const [error, setError] = useState("");
  const [labels, setLabels] = useState([]);
  const [packedLabels, setPackedLabels] = useState([]);
  const [exportMsg, setExportMsg] = useState("");
  const [exportPdfInfo, setExportPdfInfo] = useState(null);
  const [exportHtmlInfo, setExportHtmlInfo] = useState([]);
  const [exportPdfLoading, setExportPdfLoading] = useState(false);
  const [showSim, setShowSim] = useState(false);
  const [simPlaying, setSimPlaying] = useState(false);
  const [simProgress, setSimProgress] = useState(0);
  const [simSize, setSimSize] = useState({ w: 800, h: 500 });
  const [simVideoLoading, setSimVideoLoading] = useState(false);
  const simWrapRef = useRef(null);
  const [selectedZoneId, setSelectedZoneId] = useState(null);
  const [rawSegments, setRawSegments] = useState([]);
  const [borderSegments, setBorderSegments] = useState([]);
  const [nodes, setNodes] = useState([]);
  const [segs, setSegs] = useState([]);
  const [svgImage, setSvgImage] = useState(null);
  const [svgFallback, setSvgFallback] = useState([]);
  const [svgSize, setSvgSize] = useState({ w: 1000, h: 1000 });
  const stageRef = useRef(null);
  const leftRef = useRef(null);
  const overlayInputRef = useRef(null);
  const overlayTransformerRef = useRef(null);
  const overlayNodeRefs = useRef({});
  const regionNeighborCursorRef = useRef({});
  const sourceFileInputRef = useRef(null);
  const [mainViewScale, setMainViewScale] = useState(1);
  const [mainViewPos, setMainViewPos] = useState({ x: 0, y: 0 });
  const [scale, setScale] = useState(1);
  const [pos, setPos] = useState({ x: 0, y: 0 });
  const [stageSize, setStageSize] = useState({ w: 800, h: 600 });
  const regionRef = useRef(null);
  const regionWrapRef = useRef(null);
  const [regionScale, setRegionScale] = useState(1);
  const [regionPos, setRegionPos] = useState({ x: 0, y: 0 });
  const [regionStageSize, setRegionStageSize] = useState({ w: 400, h: 400 });
  const region2Ref = useRef(null);
  const region2WrapRef = useRef(null);
  const [region2Scale, setRegion2Scale] = useState(1);
  const [region2Pos, setRegion2Pos] = useState({ x: 0, y: 0 });
  const [region2StageSize, setRegion2StageSize] = useState({ w: 300, h: 200 });
  const zoneRef = useRef(null);
  const zoneWrapRef = useRef(null);
  const [zoneScale, setZoneScale] = useState(1);
  const [zonePos, setZonePos] = useState({ x: 0, y: 0 });
  const [zoneStageSize, setZoneStageSize] = useState({ w: 300, h: 200 });
  const zoneClickCacheRef = useRef([]);
  const [leftTab, setLeftTab] = useState("source");
  const [rightTab, setRightTab] = useState("packed");
  const neighborSnap = 0.5;
  const regionAdj = useMemo(
    () => buildRegionAdjacencyMulti((zoneScene || scene)?.regions || [], [neighborSnap, 2]),
    [zoneScene, scene]
  );
  const [autoFit, setAutoFit] = useState(true);
  const [showImages, setShowImages] = useState(false);
  const [showStroke, setShowStroke] = useState(true);
  const [showLabels, setShowLabels] = useState(true);
  const [labelFontFamily, setLabelFontFamily] = useState("Arial");
  const [labelFontSize, setLabelFontSize] = useState(12);
  const [packedImageSrc, setPackedImageSrc] = useState("/out/packed.svg");
  const [packedImageSrc2, setPackedImageSrc2] = useState("/out/packed_page2.svg");
  const [packedFillPaths, setPackedFillPaths] = useState([]);
  const [packedBleedPaths, setPackedBleedPaths] = useState([]);
  const [packedBleedError, setPackedBleedError] = useState("");
  const [packedFillPaths2, setPackedFillPaths2] = useState([]);
  const [packedBleedPaths2, setPackedBleedPaths2] = useState([]);
  const [packedBleedError2, setPackedBleedError2] = useState("");
  const [packedEmptyCells, setPackedEmptyCells] = useState([]);
  const [edgeMode, setEdgeMode] = useState(false);
  const [addNodeMode, setAddNodeMode] = useState(false);
  const [deleteEdgeMode, setDeleteEdgeMode] = useState(false);
  const [edgeCandidate, setEdgeCandidate] = useState(null);
  const [deleteEdgeCandidate, setDeleteEdgeCandidate] = useState(null);
  const [sceneLoading, setSceneLoading] = useState(true);
  const [packedLoading, setPackedLoading] = useState(false);
  const [packPadding, setPackPadding] = useState(0);
  const [packMargin, setPackMargin] = useState(0);
  const [packBleed, setPackBleed] = useState(10);
  const [drawScale, setDrawScale] = useState(0.5);
  const [packGrid, setPackGrid] = useState(5);
  const [packAngle, setPackAngle] = useState(5);
  const [packMode, setPackMode] = useState("fast");
  const [autoPack, setAutoPack] = useState(false);
  const [overlayItems, setOverlayItems] = useState([]);
  const [selectedOverlayId, setSelectedOverlayId] = useState(null);
  const [overlayFill, setOverlayFill] = useState("#000000");
  const [zoneClickLogs, setZoneClickLogs] = useState([]);

  const handleSourceScaleChange = (value) => {
    const next = parseFloat(value);
    if (!Number.isFinite(next) || next <= 0) return;
    const prev = sourceScale || 1;
    if (Math.abs(next - prev) < 1e-6) return;
    const ratio = next / prev;
    setAutoFit(false);
    setSourceScale(next);

    setSvgSize((s) => ({ w: s.w * ratio, h: s.h * ratio }));
    setRawSegments((s) => scaleSegments(s, ratio));
    setSvgFallback((s) => scaleSegments(s, ratio));
    setBorderSegments((s) => scaleSegments(s, ratio));
    setNodes((items) => items.map((n) => ({ ...n, x: n.x * ratio, y: n.y * ratio })));
    setOverlayItems((items) =>
      items.map((item) => ({
        ...item,
        x: item.x * ratio,
        y: item.y * ratio,
        width: item.width * ratio,
        height: item.height * ratio,
      }))
    );
    setLabels((items) =>
      items.map((lbl) => ({ ...lbl, x: lbl.x * ratio, y: lbl.y * ratio }))
    );
    setPackedLabels((items) =>
      items.map((lbl) => ({ ...lbl, x: lbl.x * ratio, y: lbl.y * ratio }))
    );
    setPackedEmptyCells((cells) => cells.map((c) => [c[0] * ratio, c[1] * ratio]));

    const nextScene = scaleSceneData(scene, ratio);
    const nextZoneScene = scaleSceneData(zoneScene, ratio);
    if (nextScene !== scene) setScene(nextScene);
    if (nextZoneScene !== zoneScene) setZoneScene(nextZoneScene);

    if (zoneClickCacheRef.current?.length) {
      zoneClickCacheRef.current = zoneClickCacheRef.current.map((pt) => ({
        ...pt,
        x: pt.x * ratio,
        y: pt.y * ratio,
      }));
      fetch("/api/source_zone_click", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ clicks: zoneClickCacheRef.current }),
      }).catch(() => {});
    }

    const packedSource = nextZoneScene || nextScene;
    if (packedSource) {
      const packedPolyData = packedSource.zone_pack_polys
        ? buildPackedZonePolyData(packedSource)
        : buildPackedPolyData(packedSource);
      setPackedEmptyCells(buildPackedEmptyCells(packedSource, packedPolyData));
    }
  };

  const simZoneIds = useMemo(() => {
    const ids = Object.keys(scene?.zone_boundaries || {});
    const getLabel = (zid) => {
      const lbl =
        scene?.zone_label_map?.[zid] ??
        scene?.zone_label_map?.[parseInt(zid, 10)] ??
        zid;
      const num = Number(lbl);
      return Number.isFinite(num) ? num : Number(zid) || 0;
    };
    return ids.sort((a, b) => getLabel(a) - getLabel(b));
  }, [scene]);
  const simZoneIndex = useMemo(() => {
    const map = {};
    simZoneIds.forEach((zid, idx) => {
      map[String(zid)] = idx;
    });
    return map;
  }, [simZoneIds]);
  const simTiming = useMemo(() => {
    const move = 1;
    const hold = 0.2;
    const per = move + hold;
    const total = simZoneIds.length ? simZoneIds.length * per : 1;
    return { move, hold, per, total };
  }, [simZoneIds]);
  const simMoveSeconds = simTiming.move;
  const simHoldSeconds = simTiming.hold;
  const simPerZone = simTiming.per;
  const simTotalSeconds = simTiming.total;
  const simActiveIdx = simZoneIds.length
    ? Math.min(
        simZoneIds.length - 1,
        Math.max(0, Math.floor((simProgress * simTotalSeconds) / simPerZone))
      )
    : -1;
  const simActiveZid = simActiveIdx >= 0 ? simZoneIds[simActiveIdx] : null;
  const simActiveLabel =
    simActiveZid != null
      ? scene?.zone_label_map?.[simActiveZid] ??
        scene?.zone_label_map?.[parseInt(simActiveZid, 10)] ??
        simActiveZid
      : "";
  const zoneLabelCenters = useMemo(() => {
    const source = zoneScene || scene;
    const centers = {};
    const boundaries = source?.zone_boundaries || {};
    Object.entries(boundaries).forEach(([zid, paths]) => {
      if (!paths || !paths.length) return;
      let best = null;
      for (const p of paths) {
        if (!p || p.length < 3) continue;
        const { area, cx, cy } = polyAreaAndCentroid(p);
        const absArea = Math.abs(area);
        if (!best || absArea > best.absArea) {
          best = { absArea, cx, cy };
        }
      }
      if (best && Number.isFinite(best.cx) && Number.isFinite(best.cy)) {
        centers[String(zid)] = { x: best.cx, y: best.cy };
      }
    });
    return centers;
  }, [zoneScene, scene]);
  const simLocalFor = (idx) => {
    if (idx == null || idx < 0) return 0;
    const t = simProgress * simTotalSeconds - idx * simPerZone;
    if (t <= 0) return 0;
    if (t >= simPerZone) return 1;
    if (t >= simMoveSeconds) return 1;
    const x = t / simMoveSeconds;
    return 1 - Math.pow(1 - x, 3);
  };

  const simStage = scene?.canvas
    ? (() => {
        const gap = 20;
        const totalW = (scene.canvas.w * 2) + gap;
        const totalH = scene.canvas.h;
        const fitScale = Math.min(simSize.w / totalW, simSize.h / totalH);
        const offsetX = (simSize.w - totalW * fitScale) / 2;
        const offsetY = (simSize.h - totalH * fitScale) / 2;
        return (
          <Stage
            width={simSize.w}
            height={simSize.h}
            scaleX={fitScale}
            scaleY={fitScale}
            x={offsetX}
            y={offsetY}
          >
            <Layer>
              <Rect
                x={0}
                y={0}
                width={scene.canvas.w}
                height={scene.canvas.h}
                stroke="#ffffff"
                strokeWidth={1}
              />
              <Rect
                x={scene.canvas.w + gap}
                y={0}
                width={scene.canvas.w}
                height={scene.canvas.h}
                stroke="#ffffff"
                strokeWidth={1}
              />
            </Layer>
            <Layer>
              {scene.region_colors
                ? scene.regions.map((poly, idx) => {
                    const zid = scene.zone_id?.[idx];
                    const zidKey = String(zid);
                    const zoneIdx = simZoneIndex[zidKey] ?? 0;
                    const local = simLocalFor(zoneIdx);
                    if (local > 0) return null;
                    const shift =
                      scene.zone_shift?.[zid] || scene.zone_shift?.[parseInt(zid, 10)];
                    if (!shift) return null;
                    const rot = scene.zone_rot?.[zid] ?? scene.zone_rot?.[parseInt(zid, 10)] ?? 0;
                    const center =
                      scene.zone_center?.[zid] || scene.zone_center?.[parseInt(zid, 10)] || [0, 0];
                    const tpts = transformPath(poly, shift, rot, center);
                    return (
                      <Line
                        key={`sim-pack-fill-${idx}`}
                        points={toPoints(tpts)}
                        closed
                        fill={scene.region_colors[idx]}
                        strokeScaleEnabled={false}
                      />
                    );
                  })
                : null}
              {packedLabels.map((lbl) => {
                const zidKey = String(lbl.zid);
                const zoneIdx = simZoneIndex[zidKey] ?? 0;
                const local = simLocalFor(zoneIdx);
                if (local > 0) return null;
                const size = Math.max(labelFontSize * 0.5, 6);
                const metrics = measureText(lbl.label, size, labelFontFamily);
                return (
                  <Text
                    key={`sim-pack-label-${lbl.id}`}
                    x={lbl.x}
                    y={lbl.y}
                    text={lbl.label}
                    fill="#ffffff"
                    fontSize={size}
                    fontFamily={labelFontFamily}
                    align="center"
                    verticalAlign="middle"
                    offsetX={metrics.width / 2}
                    offsetY={metrics.height / 2}
                  />
                );
              })}
            </Layer>
            <Layer>
              {Object.values(scene.zone_labels || {}).map((lbl) => {
                const size = Math.max(labelFontSize * 0.5, 6);
                const metrics = measureText(lbl.label, size, labelFontFamily);
                return (
                  <Text
                    key={`sim-zone-label-${lbl.label}`}
                    x={lbl.x + scene.canvas.w + gap}
                    y={lbl.y}
                    text={lbl.label}
                    fill="#ffffff"
                    fontSize={size}
                    fontFamily={labelFontFamily}
                    align="center"
                    verticalAlign="middle"
                    offsetX={metrics.width / 2}
                    offsetY={metrics.height / 2}
                  />
                );
              })}
            </Layer>
            <Layer>
              {simZoneIds.flatMap((zid) => {
                const paths = scene.zone_boundaries?.[zid] || [];
                return paths.map((p, i) => (
                  <Line
                    key={`sim-zone-${zid}-${i}`}
                    points={toPoints(offsetPoints(p, scene.canvas.w + gap, 0))}
                    stroke="#f5f6ff"
                    strokeWidth={1}
                    closed
                  />
                ));
              })}
            </Layer>
            <Layer>
              {scene.region_colors
                ? scene.regions.map((poly, idx) => {
                    const zid = scene.zone_id?.[idx];
                    const zidKey = String(zid);
                    const zoneIdx = simZoneIndex[zidKey] ?? 0;
                    const local = simLocalFor(zoneIdx);
                    const shift =
                      scene.zone_shift?.[zid] || scene.zone_shift?.[parseInt(zid, 10)];
                    if (!shift) return null;
                    const rot = scene.zone_rot?.[zid] ?? scene.zone_rot?.[parseInt(zid, 10)] ?? 0;
                    const center =
                      scene.zone_center?.[zid] ||
                      scene.zone_center?.[parseInt(zid, 10)] ||
                      [0, 0];
                    const src = transformPath(poly, shift, rot, center);
                    const dst = offsetPoints(poly, scene.canvas.w + gap, 0);
                    const pts =
                      local >= 1
                        ? dst
                        : src.map((sp, k) => {
                            const dp = dst[k] || sp;
                            return [lerp(sp[0], dp[0], local), lerp(sp[1], dp[1], local)];
                          });
                    if (local <= 0) return null;
                    return (
                      <Line
                        key={`sim-move-fill-${idx}`}
                        points={toPoints(pts)}
                        closed
                        fill={scene.region_colors[idx]}
                        strokeScaleEnabled={false}
                      />
                    );
                  })
                : null}
            </Layer>
          </Stage>
        );
      })()
    : null;

  useEffect(() => {
    loadScene();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  useEffect(() => {
    const updateSize = () => {
      if (!leftRef.current) return;
      const rect = leftRef.current.getBoundingClientRect();
      setStageSize({ w: Math.max(300, rect.width), h: Math.max(300, rect.height) });
    };
    updateSize();
    window.addEventListener("resize", updateSize);
    return () => window.removeEventListener("resize", updateSize);
  }, []);

  useEffect(() => {
    const updateRegionSize = () => {
      if (!regionWrapRef.current) return;
      const rect = regionWrapRef.current.getBoundingClientRect();
      setRegionStageSize({ w: Math.max(200, rect.width), h: Math.max(200, rect.height) });
    };
    updateRegionSize();
    window.addEventListener("resize", updateRegionSize);
    return () => window.removeEventListener("resize", updateRegionSize);
  }, []);

  useEffect(() => {
    const updateRegion2Size = () => {
      if (!region2WrapRef.current) return;
      const rect = region2WrapRef.current.getBoundingClientRect();
      setRegion2StageSize({ w: Math.max(200, rect.width), h: Math.max(200, rect.height) });
    };
    updateRegion2Size();
    window.addEventListener("resize", updateRegion2Size);
    return () => window.removeEventListener("resize", updateRegion2Size);
  }, []);

  useEffect(() => {
    const updateZoneSize = () => {
      if (!zoneWrapRef.current) return;
      const rect = zoneWrapRef.current.getBoundingClientRect();
      setZoneStageSize({ w: Math.max(200, rect.width), h: Math.max(200, rect.height) });
    };
    updateZoneSize();
    window.addEventListener("resize", updateZoneSize);
    return () => window.removeEventListener("resize", updateZoneSize);
  }, []);

  useEffect(() => {
    const raf = requestAnimationFrame(() => {
      if (leftTab === "source" && leftRef.current) {
        const rect = leftRef.current.getBoundingClientRect();
        setStageSize({ w: Math.max(300, rect.width), h: Math.max(300, rect.height) });
      }
      if (leftTab === "region" && region2WrapRef.current) {
        const rect = region2WrapRef.current.getBoundingClientRect();
        setRegion2StageSize({ w: Math.max(200, rect.width), h: Math.max(200, rect.height) });
      }
      if (leftTab === "zone" && zoneWrapRef.current) {
        const rect = zoneWrapRef.current.getBoundingClientRect();
        setZoneStageSize({ w: Math.max(200, rect.width), h: Math.max(200, rect.height) });
      }
    });
    return () => cancelAnimationFrame(raf);
  }, [leftTab]);

  useEffect(() => {
    const updateSimSize = () => {
      if (!simWrapRef.current) return;
      const rect = simWrapRef.current.getBoundingClientRect();
      setSimSize({ w: Math.max(300, rect.width), h: Math.max(200, rect.height) });
    };
    updateSimSize();
    window.addEventListener("resize", updateSimSize);
    return () => window.removeEventListener("resize", updateSimSize);
  }, []);

  useEffect(() => {
    if (!showSim) return;
    const raf = requestAnimationFrame(() => {
      if (!simWrapRef.current) return;
      const rect = simWrapRef.current.getBoundingClientRect();
      setSimSize({ w: Math.max(300, rect.width), h: Math.max(200, rect.height) });
    });
    return () => cancelAnimationFrame(raf);
  }, [showSim]);

  const fitMainViewToView = (bounds) => {
    let viewW, viewH;
    if (leftTab === "source") {
      const rect = leftRef.current?.getBoundingClientRect();
      viewW = rect?.width || stageSize.w;
      viewH = rect?.height || stageSize.h;
    } else if (leftTab === "region") {
      const rect = region2WrapRef.current?.getBoundingClientRect();
      viewW = rect?.width || region2StageSize.w;
      viewH = rect?.height || region2StageSize.h;
    } else {
      // zone
      const rect = zoneWrapRef.current?.getBoundingClientRect();
      viewW = rect?.width || zoneStageSize.w;
      viewH = rect?.height || zoneStageSize.h;
    }

    const w = bounds.maxx - bounds.minx;
    const h = bounds.maxy - bounds.miny;
    if (!w || !h || !viewW || !viewH) return;

    const fitScale = Math.min(viewW / w, viewH / h) * 0.95;
    setMainViewScale(fitScale);
    setMainViewPos({
      x: (viewW - w * fitScale) / 2 - bounds.minx * fitScale,
      y: (viewH - h * fitScale) / 2 - bounds.miny * fitScale,
    });
  };

  const fitToView = (w, h) => {
    const viewW = stageSize.w;
    const viewH = stageSize.h;
    const fitScale = Math.min(viewW / w, viewH / h) * 0.95;
    setScale(fitScale);
    setPos({
      x: (viewW - w * fitScale) / 2,
      y: (viewH - h * fitScale) / 2,
    });
  };

  const fitRegionToView = (bounds) => {
    const rect = regionWrapRef.current?.getBoundingClientRect();
    const viewW = rect?.width || regionStageSize.w;
    const viewH = rect?.height || regionStageSize.h;
    const w = bounds.maxx - bounds.minx;
    const h = bounds.maxy - bounds.miny;
    const fitScale = Math.min(viewW / w, viewH / h) * 0.95;
    setRegionScale(fitScale);
    setRegionPos({
      x: (viewW - w * fitScale) / 2 - bounds.minx * fitScale,
      y: (viewH - h * fitScale) / 2 - bounds.miny * fitScale,
    });
  };

  const fitRegion2ToView = (bounds) => {
    const rect = region2WrapRef.current?.getBoundingClientRect();
    const viewW = rect?.width || region2StageSize.w;
    const viewH = rect?.height || region2StageSize.h;
    const w = bounds.maxx - bounds.minx;
    const h = bounds.maxy - bounds.miny;
    const fitScale = Math.min(viewW / w, viewH / h) * 0.95;
    setRegion2Scale(fitScale);
    setRegion2Pos({
      x: (viewW - w * fitScale) / 2 - bounds.minx * fitScale,
      y: (viewH - h * fitScale) / 2 - bounds.miny * fitScale,
    });
  };

  const fitZoneToView = (bounds) => {
    const rect = zoneWrapRef.current?.getBoundingClientRect();
    const viewW = rect?.width || zoneStageSize.w;
    const viewH = rect?.height || zoneStageSize.h;
    const w = bounds.maxx - bounds.minx;
    const h = bounds.maxy - bounds.miny;
    const fitScale = Math.min(viewW / w, viewH / h) * 0.95;
    setZoneScale(fitScale);
    setZonePos({
      x: (viewW - w * fitScale) / 2 - bounds.minx * fitScale,
      y: (viewH - h * fitScale) / 2 - bounds.miny * fitScale,
    });
  };

  useEffect(() => {
    if (autoFit && svgSize.w && svgSize.h) {
      fitToView(svgSize.w, svgSize.h);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [svgSize, stageSize, autoFit]);

  useEffect(() => {
    if (!scene || !overlayItems.length) return;
    const updated = overlayItems.map((item) => {
      if (!item) return item;
      const zid = findZoneAtPoint({ x: item.x, y: item.y });
      return { ...item, zid: zid ?? item.zid ?? null };
    });
    const changed = updated.some((item, idx) => item?.zid !== overlayItems[idx]?.zid);
    if (changed) setOverlayItems(updated);
  }, [scene]);

  useEffect(() => {
    const tr = overlayTransformerRef.current;
    if (!tr) return;
    const node = selectedOverlayId ? overlayNodeRefs.current[selectedOverlayId] : null;
    if (node) {
      tr.nodes([node]);
    } else {
      tr.nodes([]);
    }
    tr.getLayer()?.batchDraw?.();
  }, [selectedOverlayId, overlayItems]);

  useEffect(() => {
    const onKey = (e) => {
      if (!selectedOverlayId) return;
      if (e.key !== "Delete" && e.key !== "Backspace") return;
        setOverlayItems((items) => items.filter((item) => item.id !== selectedOverlayId));
        setSelectedOverlayId(null);
      };
    window.addEventListener("keydown", onKey);
    return () => window.removeEventListener("keydown", onKey);
  }, [selectedOverlayId, nodes, segs, overlayItems]);

  useEffect(() => {
    try {
      const stored = localStorage.getItem("recentSvgFiles");
      if (!stored) return;
      const parsed = JSON.parse(stored);
      if (Array.isArray(parsed)) {
        setRecentFiles(parsed.filter((item) => item && item.filename));
      }
    } catch {
      // ignore storage errors
    }
  }, []);

  const pushRecentFile = (entry) => {
    if (!entry || !entry.filename) return;
    setRecentFiles((prev) => {
      const next = [entry, ...(prev || []).filter((item) => item?.filename !== entry.filename)];
      const trimmed = next.slice(0, 12);
      try {
        localStorage.setItem("recentSvgFiles", JSON.stringify(trimmed));
      } catch {
        // ignore storage errors
      }
      return trimmed;
    });
  };

  const loadScene = async (fit = true, updatePacked = true, updateZone = true) => {
    let loadedScene = null;
    let loadedZoneScene = null;
    try {
      setError("");
      setAutoFit(fit);
      setSceneLoading(true);
      let savedView = null;
      try {
        const stateRes = await fetch("/api/state");
        if (stateRes.ok) {
          const stateJson = await stateRes.json();
          savedView = stateJson?.view || null;
        }
      } catch {
        savedView = null;
      }
      const svgRes = await fetch("/api/source_svg");
      if (!svgRes.ok) throw new Error(`svg fetch failed: ${svgRes.status}`);
      const svgJson = await svgRes.json();
      if (!svgJson?.svg) throw new Error("svg fetch failed: empty response");
      const svgText = svgJson.svg;
      if (svgJson.name) setSourceName(svgJson.name);
      if (svgJson.filename) setSourceFilename(svgJson.filename);
      if (svgJson.name || svgJson.filename) {
        pushRecentFile({ name: svgJson.name || "", filename: svgJson.filename || "" });
      }
      const scaleRatio = sourceScale || 1;
      const parsedSize = parseSvgSize(svgText);
      const scaledSize =
        scaleRatio === 1 ? parsedSize : { w: parsedSize.w * scaleRatio, h: parsedSize.h * scaleRatio };
      setSvgSize(scaledSize);
      const overlayParsed = parseOverlayItems(svgText);
      if (overlayParsed.length) {
        const hydrated = (
          await Promise.all(
            overlayParsed.map(async (item) => {
              const img = await loadImageFromSrc(item.src);
              const width = item.width || img?.width || 0;
              const height = item.height || img?.height || 0;
              return {
                ...item,
                width,
                height,
                scaleX: Number.isFinite(item.scaleX) ? item.scaleX : 1,
                scaleY: Number.isFinite(item.scaleY) ? item.scaleY : 1,
                rotation: Number.isFinite(item.rotation) ? item.rotation : 0,
                img,
              };
            })
          )
        ).filter(Boolean);
        const scaledOverlays =
          scaleRatio === 1
            ? hydrated
            : hydrated.map((item) => ({
                ...item,
                x: item.x * scaleRatio,
                y: item.y * scaleRatio,
                width: item.width * scaleRatio,
                height: item.height * scaleRatio,
              }));
        setOverlayItems(scaledOverlays);
      } else {
        setOverlayItems([]);
      }
      setSelectedOverlayId(null);
      const parsed = buildSegmentsFromSvg(svgText);
      const segmentsRaw = parsed.segments;
      const bordersRaw = parsed.borderSegments;
      const segments = scaleRatio === 1 ? segmentsRaw : scaleSegments(segmentsRaw, scaleRatio);
      const borders = scaleRatio === 1 ? bordersRaw : scaleSegments(bordersRaw, scaleRatio);
      setSvgFallback(segments);
      setBorderSegments(borders);
      // no background rendering; keep only geometry
      setRawSegments(segments);
      const nonBorder = segments.filter(
        (seg) =>
          !borders.some(
            (b) =>
              b[0][0] === seg[0][0] &&
              b[0][1] === seg[0][1] &&
              b[1][0] === seg[1][0] &&
              b[1][1] === seg[1][1]
          )
      );
      const splitSegments = splitAtIntersections(nonBorder);
      const snapped = snapNodes(splitSegments, snap);
      setNodes(snapped.nodes);
      setSegs(snapped.segs);

      const res = await fetch(
        `/api/scene?snap=${snap}&pack_padding=${packPadding}&pack_margin_x=${packMargin}&pack_margin_y=${packMargin}&draw_scale=${drawScale}&target_zones=${targetZones}&pack_grid=${packGrid}&pack_angle=${packAngle}&pack_mode=${packMode}`
      );
      if (!res.ok) {
        throw new Error(`scene fetch failed: ${res.status}`);
      }
      const data = await res.json();
      const scaledData = scaleRatio === 1 ? data : scaleSceneData(data, scaleRatio);
      setScene(scaledData);
      loadedScene = scaledData;
      if (updateZone) {
        let zoneData = scaledData;
        try {
          const clickRes = await fetch("/api/source_zone_click");
          if (clickRes.ok) {
            const clickJson = await clickRes.json();
            const clicksRaw = normalizeClickCache(clickJson);
            const clicks =
              scaleRatio === 1
                ? clicksRaw
                : clicksRaw.map((pt) => ({ ...pt, x: pt.x * scaleRatio, y: pt.y * scaleRatio }));
            zoneClickCacheRef.current = clicks;
            if (clicks.length) {
              zoneData = applyZoneClickCache(zoneData, clicks);
            }
          }
        } catch {
          zoneClickCacheRef.current = [];
        }
        setZoneScene(zoneData);
        loadedZoneScene = zoneData;
      }
      logPackedPreview(scaledData);
      if (typeof scaledData.draw_scale === "number") {
        setDrawScale(scaledData.draw_scale);
      }
        const initLabels = Object.values(scaledData.zone_labels || {}).map((v) => ({
          id: `z-${v.label}`,
          x: v.x,
          y: v.y,
          label: `${v.label}`,
        }));
        setLabels(initLabels);
        if (updatePacked) {
          setPackedImageSrc(`/out/packed.svg?t=${Date.now()}`);
          setPackedImageSrc2(`/out/packed_page2.svg?t=${Date.now()}`);
          const packedPolyData = scaledData.zone_pack_polys
            ? buildPackedZonePolyData(scaledData)
            : buildPackedPolyData(scaledData);
          const emptyCells = buildPackedEmptyCells(scaledData, packedPolyData);
          setPackedEmptyCells(emptyCells);
          let cachedPacked = {};
          try {
            const labelRes = await fetch("/api/packed_labels");
            if (labelRes.ok) {
              cachedPacked = (await labelRes.json()) || {};
            }
          } catch {
            cachedPacked = {};
          }
          const usedCell = new Set();
          const cellIndex = (pt) => `${Math.round(pt[0] / 10)}:${Math.round(pt[1] / 10)}`;
          const nextPackedLabels = Object.entries(scaledData.zone_labels || {}).map(([zid, v]) => {
        const shift = scaledData.zone_shift?.[zid] || scaledData.zone_shift?.[parseInt(zid, 10)];
        const rot = scaledData.zone_rot?.[zid] ?? scaledData.zone_rot?.[parseInt(zid, 10)] ?? 0;
        const center = scaledData.zone_center?.[zid] || scaledData.zone_center?.[parseInt(zid, 10)] || [0, 0];
        let px = v.x;
        let py = v.y;
        const cached = cachedPacked?.[String(zid)];
        if (cached && Number.isFinite(cached.x) && Number.isFinite(cached.y)) {
          px = cached.x;
          py = cached.y;
        } else {
          let tx = v.x;
          let ty = v.y;
          if (shift) {
            const [pt] = transformPath([[v.x, v.y]], shift, rot, center);
            if (pt) {
              tx = pt[0];
              ty = pt[1];
            }
          }
          let best = null;
          let bestScore = Infinity;
          const lx = Math.round(tx / 10);
          const ly = Math.round(ty / 10);
          const minCx = lx - 10;
          const maxCx = lx + 10;
          const minCy = ly - 10;
          const maxCy = ly + 10;
          for (const cell of emptyCells) {
            const idx = cellIndex(cell);
            if (usedCell.has(idx)) continue;
            const cx = Math.round(cell[0] / 10);
            const cy = Math.round(cell[1] / 10);
            if (cx < minCx || cx > maxCx || cy < minCy || cy > maxCy) continue;
            const score = Math.abs(cx - lx) + Math.abs(cy - ly);
            if (score < bestScore) {
              bestScore = score;
              best = cell;
            }
          }
          if (best) {
            px = best[0];
            py = best[1];
            usedCell.add(cellIndex(best));
          } else {
            px = tx;
            py = ty;
          }
        }
        if (data.canvas) {
          const r = 3;
          const maxX = data.canvas.w - r;
          const maxY = data.canvas.h - r;
          px = Math.max(r, Math.min(maxX, px));
          py = Math.max(r, Math.min(maxY, py));
        }
        const mapped = data.zone_label_map?.[zid] ?? data.zone_label_map?.[parseInt(zid, 10)];
        const label = mapped != null ? mapped : v.label;
            return { id: `pz-${zid}`, zid: String(zid), x: px, y: py, label: `${label}` };
          });
          setPackedLabels(nextPackedLabels);
        }
        if (savedView?.source?.scale && savedView?.source?.pos) {
          setScale(savedView.source.scale);
          setPos(savedView.source.pos);
          setAutoFit(false);
        }
        if (savedView?.region?.scale && savedView?.region?.pos) {
          setRegionScale(savedView.region.scale);
          setRegionPos(savedView.region.pos);
        }
        if (savedView?.region2?.scale && savedView?.region2?.pos) {
          setRegion2Scale(savedView.region2.scale);
          setRegion2Pos(savedView.region2.pos);
        }
        if (savedView?.zone?.scale && savedView?.zone?.pos) {
          setZoneScale(savedView.zone.scale);
          setZonePos(savedView.zone.pos);
        }
        if (fit && !(savedView?.source?.scale && savedView?.source?.pos)) {
          const w = parsedSize.w || data.canvas?.w || 1200;
          const h = parsedSize.h || data.canvas?.h || 800;
          const viewW = stageSize.w;
          const viewH = stageSize.h;
        const fitScale = Math.min(viewW / w, viewH / h) * 0.95;
        setScale(fitScale);
        setPos({
          x: (viewW - w * fitScale) / 2,
          y: (viewH - h * fitScale) / 2,
        });
        if (data.canvas) {
          fitRegionToView({ minx: 0, miny: 0, maxx: data.canvas.w, maxy: data.canvas.h });
        } else {
          fitRegionToView(calcBounds(data.regions || []));
        }
        const regionBounds = calcBounds(data.regions || []);
        fitRegion2ToView(regionBounds);
        const zoneBounds = calcBoundsFromLines(data.zone_boundaries);
        fitZoneToView(zoneBounds);
      }
      setSceneLoading(false);
      return { scene: loadedScene, zoneScene: loadedZoneScene };
    } catch (err) {
      setError(err.message || String(err));
      setSceneLoading(false);
      return null;
    }
  };

  const handleLoadClick = () => {
    if (sourceFileInputRef.current) {
      sourceFileInputRef.current.value = "";
      sourceFileInputRef.current.click();
    }
  };

  const handleFileUpload = async (file) => {
    if (!file) return;
    try {
      setError("");
      const form = new FormData();
      form.append("file", file);
      const res = await fetch("/api/upload_svg", {
        method: "POST",
        body: form,
      });
      if (!res.ok) {
        const msg = await res.text();
        throw new Error(msg || `upload failed: ${res.status}`);
      }
      const data = await res.json();
      if (data?.name) setSourceName(data.name);
      if (data?.filename) setSourceFilename(data.filename);
      if (data?.name || data?.filename) {
        pushRecentFile({ name: data.name || "", filename: data.filename || file.name });
      }
      await loadScene(true, true, true);
    } catch (err) {
      setError(err.message || String(err));
    }
  };

  const handleRecentSelect = async (filename) => {
    if (!filename) return;
    try {
      setError("");
      const res = await fetch("/api/set_source", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ name: filename }),
      });
      if (!res.ok) {
        const msg = await res.text();
        throw new Error(msg || `set source failed: ${res.status}`);
      }
      const data = await res.json();
      if (data?.name) setSourceName(data.name);
      if (data?.filename) setSourceFilename(data.filename);
      if (data?.name || data?.filename) {
        pushRecentFile({ name: data.name || "", filename: data.filename || filename });
      }
      await loadScene(true, true, true);
    } catch (err) {
      setError(err.message || String(err));
    }
  };

  const serializeOverlays = (items) =>
    (items || []).map((item) => ({
      id: item.id,
      src: item.src,
      x: item.x,
      y: item.y,
      width: item.width,
      height: item.height,
      scaleX: item.scaleX,
      scaleY: item.scaleY,
      rotation: item.rotation,
      zid: item.zid ?? null,
    }));

  const saveSvg = (nextNodes = nodes, nextSegs = segs, nextOverlays = overlayItems) =>
    fetch("/api/save_svg", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        nodes: nextNodes,
        segs: nextSegs,
        overlays: serializeOverlays(nextOverlays),
      }),
    });

  const updateOverlayItem = (id, patch) => {
    setOverlayItems((items) =>
      items.map((item) => (item.id === id ? { ...item, ...patch } : item))
    );
  };

  const handleOverlayPick = () => {
    overlayInputRef.current?.click();
  };

  const handleOverlayFileChange = async (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    const raw = await file.text();
    const filled = applySvgFill(raw, overlayFill);
    const src = svgToDataUrl(filled);
    const img = await loadImageFromSrc(src);
    const width = img?.width || parseSvgSize(raw).w || 1;
    const height = img?.height || parseSvgSize(raw).h || 1;
    const id = `overlay-${Date.now()}`;
    const item = {
      id,
      src,
      rawSvg: raw,
      x: svgSize.w * 0.5,
      y: svgSize.h * 0.5,
      width,
      height,
      scaleX: 1,
      scaleY: 1,
      rotation: 0,
      img,
      zid: findZoneAtPoint({ x: svgSize.w * 0.5, y: svgSize.h * 0.5 }),
    };
    const next = [...overlayItems, item];
    setOverlayItems(next);
    setSelectedOverlayId(id);
    e.target.value = "";
  };

  const updateOverlayColor = async (id, color) => {
    const item = overlayItems.find((i) => i.id === id);
    if (!item) return;
    const raw = item.rawSvg || decodeSvgDataUrl(item.src);
    if (!raw) return;
    const filled = applySvgFill(raw, color);
    const src = svgToDataUrl(filled);
    const img = await loadImageFromSrc(src);
    const next = overlayItems.map((i) =>
      i.id === id ? { ...i, src, img, rawSvg: raw } : i
    );
    setOverlayItems(next);
  };

  const buildSimulateHtml = (data, packed, fontFamily, fontSize) => {
    if (!data?.canvas) return "";
    const payload = {
      canvas: data.canvas,
      regions: data.regions || [],
      zone_id: data.zone_id || [],
      zone_shift: data.zone_shift || {},
      zone_rot: data.zone_rot || {},
      zone_center: data.zone_center || {},
      zone_labels: data.zone_labels || {},
      zone_boundaries: data.zone_boundaries || {},
      zone_label_map: data.zone_label_map || {},
      region_colors: data.region_colors || [],
      packed_labels: packed || [],
      font_family: fontFamily || "Arial",
      font_size: fontSize || 12,
    };
    return `<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Simulate</title>
    <style>
      html, body { margin: 0; padding: 0; background: #0b1022; color: #e8ebff; font-family: Arial, sans-serif; }
      .wrap { width: 100vw; height: 100vh; position: relative; }
      .topbar { height: 48px; display: flex; align-items: center; justify-content: center; position: relative; z-index: 3; }
      .stage-wrap { position: absolute; top: 48px; left: 0; right: 0; bottom: 0; z-index: 1; }
      .controls { height: 42px; display: flex; align-items: center; justify-content: center; gap: 12px; padding: 4px 16px; position: absolute; left: 0; right: 0; bottom: 30px; z-index: 5; background: rgba(10, 14, 28, 0.8); backdrop-filter: blur(6px); border-top: 1px solid rgba(255, 255, 255, 0.06); }
      .controls .icon { width: 28px; height: 28px; border-radius: 6px; border: 1px solid rgba(232,235,255,0.3); background: rgba(17,21,46,0.6); color: #e8ebff; }
      .controls input[type=range] { width: 60%; max-width: 60%; }
    </style>
    <script src="https://unpkg.com/konva@9/konva.min.js"></script>
  </head>
  <body>
    <div class="wrap">
      <div class="topbar">
        <div id="movingText">Moving index: -</div>

      </div>
      <div class="controls">
        <button class="icon" id="playBtn"></button>
        <input type="range" id="slider" min="0" max="1" step="0.001" value="0" />
      </div>
      <div class="stage-wrap" id="stageWrap"></div>
    </div>
    <script>
      const data = ${JSON.stringify(payload)};
      const wrap = document.getElementById('stageWrap');
      const movingText = document.getElementById('movingText');
      const playBtn = document.getElementById('playBtn');
      const slider = document.getElementById('slider');
      const gap = 20;
      let simProgress = 0;
      let simPlaying = false;
      const move = 1;
      const hold = 0.2;
      const per = move + hold;
      const zoneIds = Object.keys(data.zone_boundaries || {});
      const getLabel = (zid) => {
        const lbl = data.zone_label_map?.[zid] ?? data.zone_label_map?.[parseInt(zid, 10)] ?? zid;
        const num = Number(lbl);
        return Number.isFinite(num) ? num : Number(zid) || 0;
      };
      zoneIds.sort((a,b) => getLabel(a) - getLabel(b));
      const total = zoneIds.length ? zoneIds.length * per : 1;
      const zoneIndex = {};
      zoneIds.forEach((zid, idx) => zoneIndex[String(zid)] = idx);
      const simLocalFor = (idx) => {
        if (idx == null || idx < 0) return 0;
        const t = simProgress * total - idx * per;
        if (t <= 0) return 0;
        if (t >= per) return 1;
        if (t >= move) return 1;
        const x = t / move;
        return 1 - Math.pow(1 - x, 3);
      };
      const rotatePt = (pt, angleDeg, cx, cy) => {
        if (!angleDeg) return pt;
        const ang = angleDeg * Math.PI / 180;
        const c = Math.cos(ang);
        const s = Math.sin(ang);
        const x = pt[0] - cx;
        const y = pt[1] - cy;
        return [cx + x * c - y * s, cy + x * s + y * c];
      };
      const transformPath = (pts, shift, rot, center) => {
        if (!pts || !pts.length) return [];
        const dx = shift?.[0] ?? 0;
        const dy = shift?.[1] ?? 0;
        const ang = rot ?? 0;
        const cx = center?.[0] ?? 0;
        const cy = center?.[1] ?? 0;
        return pts.map((p) => {
          const r = rotatePt(p, ang, cx, cy);
          return [r[0] + dx, r[1] + dy];
        });
      };
      const toPoints = (pts) => pts.flatMap(p => [p[0], p[1]]);
      const offsetPoints = (pts, dx, dy) => pts.map(p => [p[0] + dx, p[1] + dy]);
      const measureText = (text, size, family) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        ctx.font = size + 'px ' + (family || 'Arial');
        const metrics = ctx.measureText(text || '');
        return { width: metrics.width, height: size };
      };
      const stage = new Konva.Stage({ container: 'stageWrap', width: 10, height: 10 });
      const layerFrame = new Konva.Layer();
      const layerPacked = new Konva.Layer();
      const layerZoneLabels = new Konva.Layer();
      const layerZoneStroke = new Konva.Layer();
      const layerMove = new Konva.Layer();
      stage.add(layerFrame, layerPacked, layerZoneLabels, layerZoneStroke, layerMove);
      const rectLeft = new Konva.Rect({ x: 0, y: 0, width: data.canvas.w, height: data.canvas.h, stroke: '#ffffff', strokeWidth: 1 });
      const rectRight = new Konva.Rect({ x: data.canvas.w + gap, y: 0, width: data.canvas.w, height: data.canvas.h, stroke: '#ffffff', strokeWidth: 1 });
      layerFrame.add(rectLeft, rectRight);

      const packedShapes = [];
      data.regions.forEach((poly, idx) => {
        const zid = data.zone_id?.[idx];
        const zidKey = String(zid);
        const shift = data.zone_shift?.[zid] || data.zone_shift?.[parseInt(zid, 10)];
        if (!shift) return;
        const rot = data.zone_rot?.[zid] ?? data.zone_rot?.[parseInt(zid, 10)] ?? 0;
        const center = data.zone_center?.[zid] || data.zone_center?.[parseInt(zid, 10)] || [0,0];
        const packed = transformPath(poly, shift, rot, center);
        const shape = new Konva.Line({
          points: toPoints(packed),
          closed: true,
          fill: data.region_colors[idx] || '#ffffff',
          strokeScaleEnabled: false,
        });
        shape._zidKey = zidKey;
        layerPacked.add(shape);
        packedShapes.push(shape);
      });
      const packedLabels = [];
      (data.packed_labels || []).forEach((lbl) => {
        const size = Math.max((data.font_size || 12) * 0.5, 6);
        const metrics = measureText(lbl.label, size, data.font_family);
        const text = new Konva.Text({
          x: lbl.x,
          y: lbl.y,
          text: lbl.label,
          fill: '#ffffff',
          fontSize: size,
          fontFamily: data.font_family,
          align: 'center',
          verticalAlign: 'middle',
          offsetX: metrics.width / 2,
          offsetY: metrics.height / 2,
        });
        text._zidKey = String(lbl.zid);
        layerPacked.add(text);
        packedLabels.push(text);
      });

      Object.values(data.zone_labels || {}).forEach((lbl) => {
        const size = Math.max((data.font_size || 12) * 0.5, 6);
        const metrics = measureText(lbl.label, size, data.font_family);
        const text = new Konva.Text({
          x: lbl.x + data.canvas.w + gap,
          y: lbl.y,
          text: lbl.label,
          fill: '#ffffff',
          fontSize: size,
          fontFamily: data.font_family,
          align: 'center',
          verticalAlign: 'middle',
          offsetX: metrics.width / 2,
          offsetY: metrics.height / 2,
        });
        layerZoneLabels.add(text);
      });

      zoneIds.forEach((zid) => {
        const paths = data.zone_boundaries?.[zid] || [];
        paths.forEach((p) => {
          const shape = new Konva.Line({
            points: toPoints(offsetPoints(p, data.canvas.w + gap, 0)),
            stroke: '#f5f6ff',
            strokeWidth: 1,
            closed: true,
          });
          layerZoneStroke.add(shape);
        });
      });

      const movingShapes = [];
      data.regions.forEach((poly, idx) => {
        const zid = data.zone_id?.[idx];
        const zidKey = String(zid);
        const shift = data.zone_shift?.[zid] || data.zone_shift?.[parseInt(zid, 10)];
        if (!shift) return;
        const rot = data.zone_rot?.[zid] ?? data.zone_rot?.[parseInt(zid, 10)] ?? 0;
        const center = data.zone_center?.[zid] || data.zone_center?.[parseInt(zid, 10)] || [0,0];
        const src = transformPath(poly, shift, rot, center);
        const dst = offsetPoints(poly, data.canvas.w + gap, 0);
        const shape = new Konva.Line({
          points: toPoints(src),
          closed: true,
          fill: data.region_colors[idx] || '#ffffff',
          strokeScaleEnabled: false,
        });
        shape._zidKey = zidKey;
        shape._src = src;
        shape._dst = dst;
        layerMove.add(shape);
        movingShapes.push(shape);
      });

      const resize = () => {
        const rect = wrap.getBoundingClientRect();
        const totalW = (data.canvas.w * 2) + gap;
        const totalH = data.canvas.h;
        const fitScale = Math.min(rect.width / totalW, rect.height / totalH);
        const offsetX = (rect.width - totalW * fitScale) / 2;
        const offsetY = (rect.height - totalH * fitScale) / 2;
        stage.width(rect.width);
        stage.height(rect.height);
        stage.scale({ x: fitScale, y: fitScale });
        stage.position({ x: offsetX, y: offsetY });
        stage.draw();
      };
      resize();
      window.addEventListener('resize', resize);

      const update = () => {
        const activeIdx = zoneIds.length ? Math.min(zoneIds.length - 1, Math.max(0, Math.floor((simProgress * total) / per))) : -1;
        const activeZid = activeIdx >= 0 ? zoneIds[activeIdx] : null;
        const activeLabel = activeZid != null ? (data.zone_label_map?.[activeZid] ?? data.zone_label_map?.[parseInt(activeZid, 10)] ?? activeZid) : '-';
        movingText.textContent = 'Moving index: ' + activeLabel;
        packedShapes.forEach((shape) => {
          const idx = zoneIndex[shape._zidKey] ?? 0;
          const local = simLocalFor(idx);
          shape.visible(local <= 0);
        });
        packedLabels.forEach((shape) => {
          const idx = zoneIndex[shape._zidKey] ?? 0;
          const local = simLocalFor(idx);
          shape.visible(local <= 0);
        });
        movingShapes.forEach((shape) => {
          const idx = zoneIndex[shape._zidKey] ?? 0;
          const local = simLocalFor(idx);
          if (local <= 0) {
            shape.visible(false);
            return;
          }
          const pts = shape._src.map((sp, k) => {
            const dp = shape._dst[k] || sp;
            return [sp[0] + (dp[0] - sp[0]) * local, sp[1] + (dp[1] - sp[1]) * local];
          });
          shape.points(toPoints(pts));
          shape.visible(true);
        });
        layerPacked.draw();
        layerMove.draw();
      };

      const tick = (now) => {
        if (!simPlaying) return;
        const dt = 1 / 60;
        simProgress = Math.min(1, simProgress + dt / total);
        slider.value = simProgress.toFixed(3);
        if (simProgress >= 1) simPlaying = false;
        update();
        requestAnimationFrame(tick);
      };
      playBtn.addEventListener('click', () => {
        simPlaying = !simPlaying;
        playBtn.textContent = simPlaying ? '' : '';
        if (simPlaying) requestAnimationFrame(tick);
      });
      slider.addEventListener('input', (e) => {
        simProgress = parseFloat(e.target.value || '0');
        update();
      });
      update();
    </script>
  </body>
</html>`;
  };

  const handleWheel = (e) => {
    e.evt.preventDefault();
    const scaleBy = 1.05;
    const stage = stageRef.current;
    const oldScale = stage.scaleX();
    const pointer = stage.getPointerPosition();
    const mousePointTo = {
      x: (pointer.x - stage.x()) / oldScale,
      y: (pointer.y - stage.y()) / oldScale,
    };
    const direction = e.evt.deltaY > 0 ? 1 : -1;
    const newScale = direction > 0 ? oldScale / scaleBy : oldScale * scaleBy;
    setScale(newScale);
    setPos({
      x: pointer.x - mousePointTo.x * newScale,
      y: pointer.y - mousePointTo.y * newScale,
    });
  };

  const handleRegionWheel = (e) => {
    e.evt.preventDefault();
    const scaleBy = 1.05;
    const stage = regionRef.current;
    const oldScale = stage.scaleX();
    const pointer = stage.getPointerPosition();
    const mousePointTo = {
      x: (pointer.x - stage.x()) / oldScale,
      y: (pointer.y - stage.y()) / oldScale,
    };
    const direction = e.evt.deltaY > 0 ? 1 : -1;
    const newScale = direction > 0 ? oldScale / scaleBy : oldScale * scaleBy;
    setRegionScale(newScale);
    setRegionPos({
      x: pointer.x - mousePointTo.x * newScale,
      y: pointer.y - mousePointTo.y * newScale,
    });
  };

  const handleMainViewWheel = (e) => {
    e.evt.preventDefault();
    const scaleBy = 1.05;
    const stage = e.target.getStage ? e.target.getStage() : null;
    if (!stage) return;
    const oldScale = stage.scaleX();
    const pointer = stage.getPointerPosition();
    if (!pointer) return;
    const mousePointTo = {
      x: (pointer.x - stage.x()) / oldScale,
      y: (pointer.y - stage.y()) / oldScale,
    };
    const direction = e.evt.deltaY > 0 ? 1 : -1;
    const newScale = direction > 0 ? oldScale / scaleBy : oldScale * scaleBy;
    setMainViewScale(newScale);
    setMainViewPos({
      x: pointer.x - mousePointTo.x * newScale,
      y: pointer.y - mousePointTo.y * newScale,
    });
  };

  const segmentWouldIntersect = (aIdx, bIdx) => {
    if (!nodes[aIdx] || !nodes[bIdx]) return true;
    const a1 = [nodes[aIdx].x, nodes[aIdx].y];
    const a2 = [nodes[bIdx].x, nodes[bIdx].y];
    for (const [s0, s1] of segs) {
      if (s0 === aIdx || s1 === aIdx || s0 === bIdx || s1 === bIdx) {
        continue;
      }
      const b1 = [nodes[s0].x, nodes[s0].y];
      const b2 = [nodes[s1].x, nodes[s1].y];
      const inter = segmentIntersect(a1, a2, b1, b2);
      if (!inter) continue;
      if (inter.t > 1e-6 && inter.t < 1 - 1e-6 && inter.u > 1e-6 && inter.u < 1 - 1e-6) {
        return true;
      }
    }
    return false;
  };

  const findEdgeCandidate = (worldPt) => {
    if (!nodes.length) return null;
    const EDGE_HOVER_DIST = 10;
    const EDGE_MAX_LEN = 80;
    const segSet = new Set(segs.map(([a, b]) => edgeKey(a, b)));
    let best = null;
    let bestDist = Infinity;
    for (let i = 0; i < nodes.length; i++) {
      for (let j = i + 1; j < nodes.length; j++) {
        const dx = nodes[j].x - nodes[i].x;
        const dy = nodes[j].y - nodes[i].y;
        const len = Math.hypot(dx, dy);
        if (len > EDGE_MAX_LEN) continue;
        if (segSet.has(edgeKey(i, j))) continue;
        const mx = (nodes[i].x + nodes[j].x) * 0.5;
        const my = (nodes[i].y + nodes[j].y) * 0.5;
        const d = Math.hypot(worldPt.x - mx, worldPt.y - my);
        if (d > EDGE_HOVER_DIST || d >= bestDist) continue;
        if (segmentWouldIntersect(i, j)) continue;
        bestDist = d;
        best = { a: i, b: j };
      }
    }
    return best;
  };

  const findExistingEdgeCandidate = (worldPt) => {
    if (!nodes.length || !segs.length) return null;
    const EDGE_HOVER_DIST = 10;
    let best = null;
    let bestDist = Infinity;
    segs.forEach(([a, b], idx) => {
      const na = nodes[a];
      const nb = nodes[b];
      if (!na || !nb) return;
      const d = pointSegDist([worldPt.x, worldPt.y], [na.x, na.y], [nb.x, nb.y]);
      if (d <= EDGE_HOVER_DIST && d < bestDist) {
        bestDist = d;
        best = { a, b, idx };
      }
    });
    return best;
  };

  const pruneIsolatedNodes = (nextNodes, nextSegs) => {
    const connected = new Set();
    nextSegs.forEach(([a, b]) => {
      connected.add(a);
      connected.add(b);
    });
    const remap = new Map();
    const kept = [];
    nextNodes.forEach((n, idx) => {
      if (connected.has(idx)) {
        remap.set(idx, kept.length);
        kept.push({ ...n, id: kept.length });
      }
    });
    const remappedSegs = nextSegs
      .map(([a, b]) => [remap.get(a), remap.get(b)])
      .filter(([a, b]) => a != null && b != null && a !== b);
    return { nodes: kept, segs: remappedSegs };
  };

  const findZoneAtPoint = (pt) => {
    const source = zoneScene || scene;
    const zones = source?.zone_boundaries || {};
    for (const [zid, paths] of Object.entries(zones)) {
      for (const poly of paths || []) {
        if (pointInPoly([pt.x, pt.y], poly)) return String(zid);
      }
    }
    return null;
  };

  const findZoneIdByLabel = (label) => {
    const source = zoneScene || scene;
    if (!source) return String(label);
    const target = String(label);
    const map = source.zone_label_map || {};
    for (const [zid, mapped] of Object.entries(map)) {
      if (String(mapped) === target) return String(zid);
    }
    for (const [zid, info] of Object.entries(source.zone_labels || {})) {
      if (String(info?.label) === target) return String(zid);
    }
    return target;
  };

  const getZoneAlias = (zid, source) => {
    if (!source) return String(zid);
    const mapped =
      source.zone_label_map?.[zid] ??
      source.zone_label_map?.[parseInt(zid, 10)];
    if (mapped != null) return String(mapped);
    const label =
      source.zone_labels?.[zid]?.label ??
      source.zone_labels?.[parseInt(zid, 10)]?.label;
    if (label != null) return String(label);
    return String(zid);
  };

  const packedSource = zoneScene || scene;

  const packedBoxData = useMemo(() => {
    if (!packedSource?.zone_shift) return [];
    const out = [];
    const zoneOrder =
      packedSource.zone_order ||
      (packedSource.zone_pack_polys ? packedSource.zone_pack_polys.map((_, i) => i) : []);
    const polys = packedSource.zone_pack_polys || [];
    zoneOrder.forEach((zid, idx) => {
      const poly = polys?.[idx];
      if (!poly || !poly.length) return;
      const shift =
        packedSource.zone_shift?.[zid] ||
        packedSource.zone_shift?.[parseInt(zid, 10)];
      if (!shift) return;
      const rot =
        packedSource.zone_rot?.[zid] ??
        packedSource.zone_rot?.[parseInt(zid, 10)] ??
        0;
      const center =
        packedSource.zone_center?.[zid] ||
        packedSource.zone_center?.[parseInt(zid, 10)] ||
        [0, 0];
      const tpts = transformPath(poly, shift, rot, center);
      const bb = bboxFromPts(tpts);
      if (!bb) return;
      const xOffset = 0;
      out.push({
        zid: String(zid),
        label: getZoneAlias(zid, packedSource),
        minx: bb.minx,
        miny: bb.miny,
        maxx: bb.maxx,
        maxy: bb.maxy,
        xOffset,
      });
    });
    return out;
  }, [packedSource]);

  const packedEmptyCellsDerived = useMemo(() => {
    if (!packedSource) return [];
    const packedPolyData = packedSource.zone_pack_polys
      ? buildPackedZonePolyData(packedSource)
      : buildPackedPolyData(packedSource);
    return buildPackedEmptyCells(packedSource, packedPolyData);
  }, [packedSource]);

  

  const packedCellsByBin = useMemo(() => {
    return { 0: packedEmptyCellsDerived, 1: [] };
  }, [packedEmptyCellsDerived]);

  const packedLabelSnappedAll = useMemo(() => {
    if (!packedSource?.zone_boundaries) return [];
    const out = [];
    const used = new Set();
    const cellSize = 6;
    const cellIndex = (x, y) => {
      const gx = Math.round(x / cellSize);
      const gy = Math.round(y / cellSize);
      return { gx, gy };
    };
    const blockCell = (gx, gy) => {
      for (let dx = -1; dx <= 1; dx++) {
        for (let dy = -1; dy <= 1; dy++) {
          used.add(`${gx + dx}:${gy + dy}`);
        }
      }
    };
    Object.entries(packedSource.zone_boundaries || {}).forEach(([zid, paths]) => {
      if (!paths || !paths.length) return;
      const shift =
        packedSource.zone_shift?.[zid] ?? packedSource.zone_shift?.[parseInt(zid, 10)];
      const rot =
        packedSource.zone_rot?.[zid] ?? packedSource.zone_rot?.[parseInt(zid, 10)] ?? 0;
      const center =
        packedSource.zone_center?.[zid] ??
        packedSource.zone_center?.[parseInt(zid, 10)] ??
        [0, 0];
      let best = null;
      (paths || []).forEach((p) => {
        const tpts = transformPath(p, shift, rot, center);
        if (!tpts || tpts.length < 3) return;
        const { area, cx, cy } = polyAreaAndCentroid(tpts);
        const absArea = Math.abs(area);
        if (!best || absArea > best.absArea) best = { absArea, cx, cy };
      });
      if (!best) return;
      const bin =
        packedSource?.placement_bin?.[zid] ??
        packedSource?.placement_bin?.[parseInt(zid, 10)];
      const page = bin === 1 ? 1 : 0;
      const pageOffset = 0;
      const anchorX = best.cx + pageOffset;
      const anchorY = best.cy;
      const cells = packedCellsByBin[page] || [];
      let bestCell = null;
      let bestD = Infinity;
      for (const cell of cells) {
        const dx0 = cell[0] - anchorX;
        const dy0 = cell[1] - anchorY;
        const d = dx0 * dx0 + dy0 * dy0;
        const { gx, gy } = cellIndex(cell[0], cell[1]);
        if (used.has(`${gx}:${gy}`)) continue;
        if (d < bestD) {
          bestD = d;
          bestCell = cell;
        }
      }
      const x = bestCell ? bestCell[0] : anchorX;
      const y = bestCell ? bestCell[1] : anchorY;
      if (bestCell) {
        const { gx, gy } = cellIndex(bestCell[0], bestCell[1]);
        blockCell(gx, gy);
      }
      const label = getZoneAlias(zid, packedSource);
      out.push({ zid, label, x, y, page });
    });
    return out;
  }, [packedCellsByBin, packedSource]);


  const findRegionAtPoint = (regions, pt) => {
    if (!regions || !pt) return -1;
    for (let i = 0; i < regions.length; i++) {
      if (pointInPoly([pt.x, pt.y], regions[i])) return i;
    }
    return -1;
  };

  const normalizeClickCache = (payload) => {
    if (Array.isArray(payload)) return payload;
    if (payload && Array.isArray(payload.clicks)) return payload.clicks;
    return [];
  };

  const refreshPackedFromZoneScene = async (source) => {
    if (!source?.regions || !source?.zone_id || !source?.canvas) return;
    try {
      const res = await fetch("/api/pack_from_scene", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          canvas: source.canvas,
          regions: source.regions,
          zone_id: source.zone_id,
          region_colors: source.region_colors || [],
          pack_padding: packPadding,
          pack_margin_x: packMargin,
          pack_margin_y: packMargin,
          pack_grid: packGrid,
          pack_angle: packAngle,
          pack_mode: packMode,
        }),
      });
      if (!res.ok) {
        throw new Error(`pack_from_scene failed: ${res.status}`);
      }
      const data = await res.json();
      if (data?.packed_svg) {
        const parsed = parsePackedSvg(data.packed_svg);
        setPackedFillPaths(parsed.fillPaths);
        setPackedBleedPaths(parsed.bleedPaths);
        setPackedBleedError(parsed.hasBleed ? "" : "packed.svg missing bleed layer");
      }
      if (data?.packed_svg_page2) {
        const parsed2 = parsePackedSvg(data.packed_svg_page2);
        setPackedFillPaths2(parsed2.fillPaths);
        setPackedBleedPaths2(parsed2.bleedPaths);
        setPackedBleedError2(parsed2.hasBleed ? "" : "packed_page2.svg missing bleed layer");
      }
      if (data?.zone_shift || data?.zone_rot || data?.zone_center || data?.placement_bin) {
        setZoneScene((prev) =>
          prev
            ? {
                ...prev,
                zone_shift: data.zone_shift || prev.zone_shift,
                zone_rot: data.zone_rot || prev.zone_rot,
                zone_center: data.zone_center || prev.zone_center,
                placement_bin: data.placement_bin || prev.placement_bin,
                zone_pack_polys: data.zone_pack_polys || prev.zone_pack_polys,
                zone_order: data.zone_order || prev.zone_order,
              }
            : prev
        );
      }
    } catch (err) {
      setPackedBleedError(err.message || String(err));
    }
  };

  const getZoneStageWorldPoint = (evt) => {
    const stage = evt?.target?.getStage?.() || zoneRef.current;
    if (!stage) return null;
    const pointer = stage.getPointerPosition?.();
    if (!pointer) return null;
    const scale = stage.scaleX?.() || mainViewScale || 1;
    const x = (pointer.x - stage.x()) / scale;
    const y = (pointer.y - stage.y()) / scale;
    return { x, y };
  };

  const saveZoneClickCache = async (pt) => {
    if (!pt || !Number.isFinite(pt.x) || !Number.isFinite(pt.y)) return;
    const next = [...zoneClickCacheRef.current, { x: pt.x, y: pt.y }];
    zoneClickCacheRef.current = next;
    try {
      await fetch("/api/source_zone_click", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ clicks: next }),
      });
    } catch {
      // ignore cache write errors
    }
  };

  const applyZoneDetachAttach = (source, rid, adj, cursorMap) => {
    if (!source?.regions || !source?.zone_id) return { source, changed: false };
    if (rid == null || rid < 0 || rid >= source.regions.length) return { source, changed: false };
    const currentZid = source.zone_id[rid];
    const neighbors = adj?.[rid] || [];
    if (!neighbors.length) return { source, changed: false };
    const neighborZids = [];
    const seen = new Set();
    for (const nb of neighbors) {
      const zid = source.zone_id[nb];
      if (zid == null) continue;
      if (String(zid) === String(currentZid)) continue;
      const key = String(zid);
      if (seen.has(key)) continue;
      seen.add(key);
      neighborZids.push(zid);
    }
    if (!neighborZids.length) return { source, changed: false };
    neighborZids.sort((a, b) => Number(a) - Number(b));
    const cursor = cursorMap[rid] || 0;
    const targetZid = neighborZids[cursor % neighborZids.length];
    cursorMap[rid] = (cursor + 1) % neighborZids.length;
    const nextZoneId = source.zone_id.slice();
    nextZoneId[rid] = targetZid;
    const nextBoundaries = buildZoneBoundaries(source.regions, nextZoneId, 0);
    return {
      source: { ...source, zone_id: nextZoneId, zone_boundaries: nextBoundaries },
      changed: true,
      targetZid,
      currentZid,
      neighborZids,
    };
  };

  const applyZoneClickCache = (base, clicks) => {
    if (!base?.regions || !base?.zone_id || !clicks?.length) return base;
    const adj = buildRegionAdjacencyMulti(base.regions || [], [neighborSnap, 2]);
    const cursorMap = {};
    let nextSource = base;
    let lastTarget = null;
    clicks.forEach((pt, idx) => {
      if (!pt || !Number.isFinite(pt.x) || !Number.isFinite(pt.y)) return;
      const rid = findRegionAtPoint(nextSource.regions, pt);
      if (rid < 0) {
        console.log(`[zone] replay ${idx} miss x=${pt.x} y=${pt.y}`);
        return;
      }
      const res = applyZoneDetachAttach(nextSource, rid, adj, cursorMap);
      if (!res.changed) return;
      const currentAlias = getZoneAlias(res.currentZid, nextSource);
      const neighborAliases = (res.neighborZids || []).map((zid) =>
        getZoneAlias(zid, nextSource)
      );
      console.log(
        `[zone] replay ${idx} region=${rid} current=${currentAlias} neighbors=${neighborAliases.join(
          ", "
        )}`
      );
      const targetAlias = getZoneAlias(res.targetZid, nextSource);
      console.log(`[zone] replay ${idx} region=${rid} attach=${targetAlias}`);
      nextSource = res.source;
      lastTarget = res.targetZid;
    });
    if (lastTarget != null) setSelectedZoneId(String(lastTarget));
    return nextSource;
  };

  const renderLeftDebug = () => (
    <div className="left-debug">
      <div className="zone-count">
        Zones: {scene?.zone_id ? Math.max(...scene.zone_id) + 1 : 0}
      </div>
      <div className="zone-count">
        Debug:
        {scene?.debug
          ? ` raw=${scene.debug.polygons_raw || 0} kept=${scene.debug.polygons_final || 0} small=${scene.debug.polygons_removed_small || 0} largest=${scene.debug.polygons_removed_largest || 0} tri_keep=${scene.debug.tri_kept || 0} tri_small=${scene.debug.tri_removed_small || 0} tri_out=${scene.debug.tri_removed_outside || 0} packed=${scene.debug.packed_placed || 0}/${scene.debug.zones_total || 0}`
          : " n/a"}
      </div>
      <div className="zone-count">
        ZonePoly:
        {scene?.debug
          ? ` empty=${(scene.debug.zones_empty || []).length} hull=${(scene.debug.zones_convex_hull || []).length}`
          : " n/a"}
      </div>
      {zoneClickLogs.slice(-4).map((line, idx) => (
        <div className="zone-count" key={`zlog-${idx}`}>
          {line}
        </div>
      ))}
    </div>
  );

  const handleZoneRegionClick = (rid, evt) => {
    const source = zoneScene || scene;
    if (!source) return;
    const clickPt = getZoneStageWorldPoint(evt);
    if (clickPt) saveZoneClickCache(clickPt);
    const adjAll = buildRegionAdjacencyMulti(source.regions || [], [neighborSnap, 2]);
    const res = applyZoneDetachAttach(
      source,
      rid,
      adjAll,
      regionNeighborCursorRef.current
    );
    if (!res.changed) return;
    const currentAlias = getZoneAlias(res.currentZid, source);
    const neighborAliases = (res.neighborZids || []).map((zid) => getZoneAlias(zid, source));
    const clickLine = `Click: ${currentAlias} -> [${neighborAliases.join(", ")}]`;
    setZoneClickLogs((logs) => [...logs.slice(-20), clickLine]);
    console.log(
      `[zone] region=${rid} current=${currentAlias} neighbors=${neighborAliases.join(", ")}`
    );
    const targetAlias = getZoneAlias(res.targetZid, source);
    console.log(`[zone] region=${rid} attach=${targetAlias}`);
    setZoneScene(res.source);
    setSelectedZoneId(String(res.targetZid));
  };

  const panMainViewToPoint = (pt) => {
    if (!pt) return;
    const viewW = stageSize.w || 0;
    const viewH = stageSize.h || 0;
    const scale = mainViewScale || 1;
    if (viewW <= 0 || viewH <= 0) return;
    setMainViewPos({
      x: viewW / 2 - pt.x * scale,
      y: viewH / 2 - pt.y * scale,
    });
  };

  const handlePackedZoneClick = (zid) => {
    const key = String(zid);
    setSelectedZoneId(key);
    const center = zoneLabelCenters?.[key];
    if (center && Number.isFinite(center.x) && Number.isFinite(center.y)) {
      panMainViewToPoint(center);
      return;
    }
    const source = zoneScene || scene;
    if (!source) return;
    const lbl =
      source.zone_labels?.[key] ??
      source.zone_labels?.[parseInt(key, 10)];
    if (lbl && Number.isFinite(lbl.x) && Number.isFinite(lbl.y)) {
      panMainViewToPoint({ x: lbl.x, y: lbl.y });
    }
  };

  const transformOverlayToPacked = (item) => {
    const source = packedSource || scene;
    if (!source || !item || item.zid == null) return item;
    const zid = item.zid;
    const shift = source.zone_shift?.[zid] || source.zone_shift?.[parseInt(zid, 10)];
    const rot = source.zone_rot?.[zid] ?? source.zone_rot?.[parseInt(zid, 10)] ?? 0;
    const center =
      source.zone_center?.[zid] || source.zone_center?.[parseInt(zid, 10)] || [0, 0];
    const [pt] = transformPath([[item.x, item.y]], shift, rot, center);
    return {
      ...item,
      x: pt[0],
      y: pt[1],
      rotation: (item.rotation || 0) + (rot || 0),
    };
  };

  const saveState = async () => {
    if (!scene) return;
    await fetch("/api/state", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        canvas: scene.canvas,
        regions: scene.regions,
        zone_boundaries: scene.zone_boundaries,
        svg_nodes: nodes,
        svg_segments: segs,
        labels,
        snap,
        view: {
          mainView: { scale: mainViewScale, pos: mainViewPos },
          region: { scale: regionScale, pos: regionPos },
        },
      }),
    });
  };

  const exportPdf = async () => {
    try {
      setError("");
      setExportMsg("");
      if (!scene?.canvas) {
        throw new Error("canvas missing");
      }
      setExportPdfLoading(true);
      await new Promise((r) => requestAnimationFrame(r));
      setExportPdfInfo(null);
      const size = { w: scene.canvas.w, h: scene.canvas.h };
      const targetMm = { w: 260, h: 190 };
      const fontSizeMm = 2.0;
      const fontSizePx = size.w > 0 ? (size.w / targetMm.w) * fontSizeMm : labelFontSize;
      const prevSelected = selectedZoneId;
      setSelectedZoneId(null);
      const zoneLabelsSvg = (svgText) =>
        injectSvgLabels(svgText, scene.zone_labels, labelFontFamily, labelFontSize, zoneLabelCenters);
      const pages = [
          {
            name: "zone_image",
            svg: zoneLabelsSvg(
              captureStageSvg(zoneRef, size, {
                "zone-image": true,
                "zone-overlay": true,
                "zone-stroke": true,
                "zone-label": true,
                "zone-hit": false,
              })
            ),
            opts: { darkenExistingStroke: true, removeFill: false },
          },
          {
            name: "zone_noimage",
            svg: zoneLabelsSvg(
              captureStageSvg(zoneRef, size, {
                "zone-image": false,
                "zone-overlay": true,
                "zone-stroke": true,
                "zone-label": true,
                "zone-hit": false,
              })
            ),
            opts: { forceStroke: true, removeFill: true },
          },
          {
            name: "packed_image_nostroke",
            svg: captureStageSvg(regionRef, size, {
              "packed-image": true,
              "packed-overlay": true,
              "packed-stroke": false,
              "packed-label": true,
              "packed-hit": false,
            }),
            opts: { forceStroke: false, removeFill: false },
          },
          {
            name: "packed_noimage_stroke_nolabel",
            svg: captureStageSvg(regionRef, size, {
              "packed-image": false,
              "packed-overlay": true,
              "packed-stroke": true,
              "packed-label": false,
              "packed-hit": false,
            }),
            opts: { forceStroke: true, removeFill: true },
          },
      ];
      const orientation = "l";
      const pdf = new jsPDF({
        unit: "mm",
        format: [targetMm.w, targetMm.h],
        orientation,
      });
      for (let i = 0; i < pages.length; i++) {
        const page = pages[i];
        if (!page?.svg) continue;
        if (i > 0) {
          pdf.addPage([targetMm.w, targetMm.h], orientation);
        }
        const normalized = normalizePdfSvg(page.svg, size, targetMm, fontSizePx, page.opts);
        const doc = new DOMParser().parseFromString(normalized, "image/svg+xml");
        const svgEl = doc.querySelector("svg");
        if (!svgEl) continue;
        await svg2pdf(svgEl, pdf, { x: 0, y: 0, width: targetMm.w, height: targetMm.h });
      }
      setSelectedZoneId(prevSelected);
      const baseName = (sourceName || "source").replace(/[\\/:*?"<>|]+/g, "_");
      const pdfName = `${baseName}_output.pdf`;
      pdf.save(pdfName);

      const htmlNames = [];
      try {
        const html0 = buildSimulateHtml(scene, packedLabels, labelFontFamily, labelFontSize);
        if (html0) {
          const name0 = `${baseName}_simulate.html`;
          await fetch("/api/save_html", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              name: name0,
              html: html0,
            }),
          });
          htmlNames.push(name0);
        }
      } catch {
        // ignore html export errors
      }
      setExportHtmlInfo(htmlNames);
      setExportMsg("Export PDF Done");
      setTimeout(() => setExportMsg(""), 3000);
    } catch (err) {
      setError(err.message || String(err));
    } finally {
      setExportPdfLoading(false);
    }
  };

  useEffect(() => {
    if (!simPlaying) return;
    let raf = 0;
    let last = performance.now();
    const tick = (now) => {
      const dt = (now - last) / 1000;
      last = now;
      setSimProgress((p) => {
        const next = Math.min(1, p + dt / simTotalSeconds);
        if (next >= 1) setSimPlaying(false);
        return next;
      });
      raf = requestAnimationFrame(tick);
    };
    raf = requestAnimationFrame(tick);
    return () => cancelAnimationFrame(raf);
  }, [simPlaying, simTotalSeconds]);

  useEffect(() => {
    if (!autoPack) return;
    const id = setTimeout(() => {
      loadScene(false);
    }, 500);
    return () => clearTimeout(id);
  }, [packPadding, packMargin, packBleed, targetZones, packGrid, packAngle, packMode, autoPack]);

  const parsePackedSvg = (text) => {
    const doc = new DOMParser().parseFromString(text, "image/svg+xml");
    const fill = doc.querySelector('g#fill');
    const bleed = doc.querySelector('g#bleed');
    const parsePaths = (node) =>
      Array.from(node?.querySelectorAll("path") || []).map((p) => ({
        d: p.getAttribute("d") || "",
        fill: p.getAttribute("fill") || "#000000",
      }));
    const fillPaths = parsePaths(fill).filter((p) => p.d);
    const bleedPaths = parsePaths(bleed).filter((p) => p.d);
    return { fillPaths, bleedPaths, hasBleed: !!bleed };
  };

  function lerp(a, b, t) {
    return a + (b - a) * t;
  }

  const escapeXml = (value) => {
    if (value == null) return "";
    return String(value)
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&apos;");
  };

  const matrixToAttr = (m) => {
    if (!m || m.length < 6) return "";
    const [a, b, c, d, e, f] = m.map((v) => (Number.isFinite(v) ? v : 0));
    return `matrix(${a} ${b} ${c} ${d} ${e} ${f})`;
  };

  const buildSvgFromStage = (stage, exportSize = null) => {
    const width = exportSize?.w || stage.width();
    const height = exportSize?.h || stage.height();
    const parts = [
      `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">`,
    ];

    const pushAttrs = (attrs) => {
      const out = [];
      Object.entries(attrs).forEach(([key, val]) => {
        if (val == null || val === "" || val === false) return;
        out.push(`${key}="${escapeXml(val)}"`);
      });
      return out.join(" ");
    };

    const addShape = (node) => {
      if (!node.isVisible?.() || node.opacity?.() === 0) return;
      const transform = node.getAbsoluteTransform?.();
      const matrix = transform ? matrixToAttr(transform.getMatrix()) : "";
      const strokeScaleEnabled =
        typeof node.strokeScaleEnabled === "function" ? node.strokeScaleEnabled() : true;
      const common = {
        transform: matrix || undefined,
        opacity: node.opacity?.(),
        fill: node.fill?.() ?? undefined,
        "fill-opacity": node.fillOpacity?.(),
        stroke: node.stroke?.() ?? undefined,
        "stroke-opacity": node.strokeOpacity?.(),
        "stroke-width": node.strokeWidth?.(),
        "vector-effect": strokeScaleEnabled ? undefined : "non-scaling-stroke",
      };

      const className = node.getClassName?.();
      if (className === "Line") {
        const pts = node.points?.() || [];
        if (pts.length < 2) return;
        const pairs = [];
        for (let i = 0; i + 1 < pts.length; i += 2) {
          pairs.push(`${pts[i]},${pts[i + 1]}`);
        }
        const closed = node.closed?.();
        const tag = closed ? "polygon" : "polyline";
        const attrs = {
          ...common,
          points: pairs.join(" "),
          fill: closed ? common.fill ?? "none" : "none",
        };
        parts.push(`<${tag} ${pushAttrs(attrs)} />`);
        return;
      }

      if (className === "Path") {
        const d = node.data?.();
        if (!d) return;
        const attrs = { ...common, d };
        parts.push(`<path ${pushAttrs(attrs)} />`);
        return;
      }

      if (className === "Rect") {
        const w = node.width?.();
        const h = node.height?.();
        if (!w || !h) return;
        const attrs = { ...common, x: 0, y: 0, width: w, height: h };
        parts.push(`<rect ${pushAttrs(attrs)} />`);
        return;
      }

        if (className === "Circle") {
          const r = node.radius?.();
          if (!r) return;
          const attrs = { ...common, cx: 0, cy: 0, r };
          parts.push(`<circle ${pushAttrs(attrs)} />`);
          return;
        }

        if (className === "Image") {
          const img = node.image?.();
          const src = img?.src;
          const w = node.width?.();
          const h = node.height?.();
          if (!src || !w || !h) return;
          const attrs = { ...common, x: 0, y: 0, width: w, height: h, href: src };
          parts.push(`<image ${pushAttrs(attrs)} />`);
          return;
        }

        if (className === "Text") {
          const text = node.text?.();
          if (text == null) return;
        const absPos = node.getAbsolutePosition?.() || { x: 0, y: 0 };
        const attrs = {
          fill: common.fill,
          "fill-opacity": common["fill-opacity"],
          stroke: common.stroke,
          "stroke-opacity": common["stroke-opacity"],
          "stroke-width": common["stroke-width"],
          opacity: common.opacity,
          x: absPos.x,
          y: absPos.y,
          "font-size": node.fontSize?.(),
          "font-family": node.fontFamily?.(),
          "text-anchor": node.align?.() === "center" ? "middle" : undefined,
          "dominant-baseline": "middle",
        };
        parts.push(`<text ${pushAttrs(attrs)}>${escapeXml(text)}</text>`);
      }
    };

    const walk = (node) => {
      const className = node.getClassName?.();
      if (className === "Group" || className === "Layer" || className === "Stage") {
        const children = node.getChildren?.() || [];
        children.forEach((child) => walk(child));
        return;
      }
      addShape(node);
    };

    walk(stage);
    parts.push("</svg>");
    return parts.join("");
  };

  const handleSimVideoDownload = async () => {
    if (simVideoLoading || !scene) return;
    setSimVideoLoading(true);
    try {
      const res = await fetch("/api/export_sim_video", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          scene,
          packedLabels,
          fontName: labelFontFamily,
          fontSize: labelFontSize,
        }),
      });
      if (!res.ok) {
        const data = await res.json().catch(() => ({}));
        throw new Error(data.error || `export failed: ${res.status}`);
      }
      const data = await res.json().catch(() => ({}));
      if (data?.name) {
        const dl = await fetch(`/api/download_sim_video?name=${encodeURIComponent(data.name)}`);
        if (!dl.ok) {
          const msg = await dl.text().catch(() => "");
          throw new Error(msg || `download failed: ${dl.status}`);
        }
        const blob = await dl.blob();
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = data.name;
        document.body.appendChild(link);
        link.click();
        link.remove();
        URL.revokeObjectURL(url);
      }
    } catch (err) {
      setError(err.message || String(err));
    } finally {
      setSimVideoLoading(false);
    }
  };

  const handleSimPlayToggle = () => {
    if (!simPlaying && simProgress >= 1) {
      setSimProgress(0);
    }
    setSimPlaying((v) => !v);
  };

  const injectSvgLabels = (svgText, labels, fontFamily, fontSize, centers = null) => {
    try {
      const doc = new DOMParser().parseFromString(svgText, "image/svg+xml");
      const svg = doc.querySelector("svg");
      if (!svg) return svgText;
      Array.from(svg.querySelectorAll("text")).forEach((n) => n.remove());
      Object.entries(labels || {}).forEach(([zid, lbl]) => {
        const c = centers?.[String(zid)];
        const x = Number(c?.x ?? lbl.x);
        const y = Number(c?.y ?? lbl.y);
        if (!Number.isFinite(x) || !Number.isFinite(y)) return;
        const text = doc.createElementNS("http://www.w3.org/2000/svg", "text");
        text.setAttribute("x", String(x));
        text.setAttribute("y", String(y));
        text.setAttribute("fill", "#ffffff");
        text.setAttribute("font-family", fontFamily || "Arial");
        text.setAttribute("font-size", String(fontSize || 12));
        text.setAttribute("text-anchor", "middle");
        text.setAttribute("dominant-baseline", "middle");
        text.textContent = String(lbl.label ?? "");
        svg.appendChild(text);
      });
      return new XMLSerializer().serializeToString(svg);
    } catch {
      return svgText;
    }
  };

  const handleSimHtmlDownload = () => {
    if (!scene) return;
    const html = buildSimulateHtml(scene, packedLabels, labelFontFamily, labelFontSize);
    if (!html) return;
    const baseName = (sourceName || "source").replace(/[\\/:*?"<>|]+/g, "_");
    const name = `${baseName}_simulate.html`;
    const blob = new Blob([html], { type: "text/html;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = name;
    document.body.appendChild(link);
    link.click();
    link.remove();
    URL.revokeObjectURL(url);
  };

  const normalizePdfSvg = (svgText, canvasSize, targetMm, fontSizePx = null, opts = {}) => {
    try {
      const doc = new DOMParser().parseFromString(svgText, "image/svg+xml");
      const svg = doc.querySelector("svg");
      if (!svg) return svgText;
      const viewW = canvasSize?.w || 0;
      const viewH = canvasSize?.h || 0;
      if (viewW > 0 && viewH > 0) {
        svg.setAttribute("viewBox", `0 0 ${viewW} ${viewH}`);
      }
      svg.setAttribute("width", `${targetMm.w}mm`);
      svg.setAttribute("height", `${targetMm.h}mm`);
      svg.setAttribute("style", "background:#ffffff");
      const forceStroke = !!opts.forceStroke;
      const removeFill = !!opts.removeFill;
      const darkenExistingStroke = !!opts.darkenExistingStroke;
      // Force any full-canvas rects to white.
      Array.from(svg.querySelectorAll("rect")).forEach((r) => {
        const w = parseFloat(r.getAttribute("width") || "0");
        const h = parseFloat(r.getAttribute("height") || "0");
        if (viewW > 0 && viewH > 0 && w >= viewW * 0.98 && h >= viewH * 0.98) {
          r.setAttribute("fill", "#ffffff");
          r.setAttribute("stroke", "none");
        }
        if (forceStroke) {
          r.setAttribute("stroke", "#000000");
          r.setAttribute("stroke-width", "1");
        }
        if (removeFill) {
          r.setAttribute("fill", "none");
        }
      });
      if (forceStroke) {
        Array.from(svg.querySelectorAll("path,polyline,polygon,rect,line")).forEach((el) => {
          el.setAttribute("stroke", "#000000");
          el.setAttribute("stroke-width", "1");
          if (removeFill) {
            el.setAttribute("fill", "none");
          }
        });
      } else if (darkenExistingStroke) {
        Array.from(svg.querySelectorAll("path,polyline,polygon,rect,line")).forEach((el) => {
          const stroke = el.getAttribute("stroke");
          if (!stroke || stroke === "none") return;
          el.setAttribute("stroke", "#000000");
          el.setAttribute("stroke-width", "1");
        });
      }
      const rect = doc.createElementNS("http://www.w3.org/2000/svg", "rect");
      rect.setAttribute("x", "0");
      rect.setAttribute("y", "0");
      rect.setAttribute("width", String(viewW || targetMm.w));
      rect.setAttribute("height", String(viewH || targetMm.h));
      rect.setAttribute("fill", "#ffffff");
      svg.insertBefore(rect, svg.firstChild);
      if (fontSizePx != null) {
        Array.from(svg.querySelectorAll("text")).forEach((t) => {
          t.setAttribute("font-size", String(fontSizePx));
          t.setAttribute("fill", "#000000");
          t.setAttribute("stroke", "none");
          t.setAttribute("stroke-width", "0");
        });
      }
      return new XMLSerializer().serializeToString(svg);
    } catch {
      return svgText;
    }
  };

  const captureStageSvg = (ref, exportSize = null, layerVisibility = null) => {
    const stage = ref?.current;
    if (!stage) return "";
    const prevScale = stage.scale();
    const prevPos = stage.position();
    const prevVis = [];
    const applyVis = (name, visible) => {
      let nodes = stage.find(`.${name}`) || [];
      let list = nodes?.toArray ? nodes.toArray() : nodes;
      if (!list || list.length === 0) {
        nodes = stage.find((n) => (n.name && n.name() === name) || false) || [];
        list = nodes?.toArray ? nodes.toArray() : nodes;
      }
      (list || []).forEach((n) => {
        prevVis.push([n, n.visible()]);
        n.visible(visible);
      });
    };
    if (layerVisibility) {
      Object.entries(layerVisibility).forEach(([name, visible]) => applyVis(name, visible));
    }
    stage.scale({ x: 1, y: 1 });
    stage.position({ x: 0, y: 0 });
    stage.draw();
    const svg =
      typeof stage.toSVG === "function"
        ? stage.toSVG()
        : buildSvgFromStage(stage, exportSize);
    prevVis.forEach(([node, vis]) => node.visible(vis));
    stage.scale(prevScale);
    stage.position(prevPos);
    stage.draw();
    return svg;
  };

  const downloadStage = (ref, filename, exportSize = null) => {
    try {
      const svg = captureStageSvg(ref, exportSize);
      try {
        let suffix = "";
        if (showImages) suffix += "_image";
        if (showStroke) suffix += "_stroke";
        suffix += showLabels ? "_label" : "_nolabel";
        const nameWithSuffix = filename.replace(/\.svg$/i, `${suffix}.svg`);
        fetch("/api/save_konva_svg", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ name: nameWithSuffix, svg }),
        });
      } catch {
        // ignore save errors
      }
      // backend save only
    } catch {
      // ignore download errors
    }
  };

  useEffect(() => {
    if (zoneScene) return;
    if (!packedImageSrc) return;
    fetch(packedImageSrc)
      .then((res) => res.text())
      .then((text) => {
        const parsed = parsePackedSvg(text);
        setPackedFillPaths(parsed.fillPaths);
        setPackedBleedPaths(parsed.bleedPaths);
        if (!parsed.hasBleed) {
          setPackedBleedError("packed.svg missing bleed layer");
        } else {
          setPackedBleedError("");
        }
      })
      .catch(() => {
        setPackedFillPaths([]);
        setPackedBleedPaths([]);
        setPackedBleedError("packed.svg failed to load");
      });
  }, [packedImageSrc]);

  useEffect(() => {
    if (zoneScene) return;
    if (!packedImageSrc2) return;
    fetch(packedImageSrc2)
      .then((res) => res.text())
      .then((text) => {
        const parsed = parsePackedSvg(text);
        setPackedFillPaths2(parsed.fillPaths);
        setPackedBleedPaths2(parsed.bleedPaths);
        if (!parsed.hasBleed) {
          setPackedBleedError2("packed_page2.svg missing bleed layer");
        } else {
          setPackedBleedError2("");
        }
      })
      .catch(() => {
        setPackedFillPaths2([]);
        setPackedBleedPaths2([]);
        setPackedBleedError2("packed_page2.svg failed to load");
      });
  }, [packedImageSrc2]);

  const nodeLayer = useMemo(() => {
    if (!segs.length || !nodes.length) return null;
    return segs.map(([a, b], idx) => {
      const p1 = nodes[a];
      const p2 = nodes[b];
      return (
        <Line
          key={`s-${idx}`}
          points={[p1.x, p1.y, p2.x, p2.y]}
          stroke="#f5f6ff"
          strokeWidth={(1 / scale) * 2.5}
          strokeScaleEnabled={false}
        />
      );
    });
  }, [segs, nodes]);

  const borderLayer = useMemo(() => {
    if (!borderSegments.length) return null;
    return borderSegments.map((seg, idx) => (
      <Line
        key={`b-${idx}`}
        points={toPoints(seg)}
        stroke="#f5f6ff"
        strokeWidth={(1 / scale) * 2.5}
        strokeScaleEnabled={false}
      />
    ));
  }, [borderSegments]);

  function offsetPoints(pts, dx, dy) {
    return (pts || []).map((p) => [p[0] + dx, p[1] + dy]);
  }

  const zoneColorMap = useMemo(() => {
    if (!scene?.region_colors || !scene?.zone_id) return {};
    const map = {};
    for (let i = 0; i < scene.zone_id.length; i++) {
      const zid = scene.zone_id[i];
      if (map[zid]) continue;
      const color = scene.region_colors[i];
      if (color) map[zid] = color;
    }
    return map;
  }, [scene]);

  useEffect(() => {
    if (autoFit && (scene?.canvas || scene?.regions?.length)) {
      if (leftTab === 'region') {
        fitMainViewToView(calcBounds(scene.regions || []));
      } else if (leftTab === 'zone') {
        fitMainViewToView(calcBoundsFromLines(scene.zone_boundaries));
      } else {
        if (scene?.canvas) {
          fitMainViewToView({ minx: 0, miny: 0, maxx: scene.canvas.w, maxy: scene.canvas.h });
        } else {
          fitMainViewToView(calcBounds(scene.regions || []));
        }
      }

      if (scene?.canvas) {
        fitRegionToView({ minx: 0, miny: 0, maxx: scene.canvas.w, maxy: scene.canvas.h });
      } else {
        fitRegionToView(calcBounds(scene.regions || []));
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [scene, stageSize, regionStageSize, region2StageSize, zoneStageSize, autoFit, leftTab]);

  const recentOptions = useMemo(() => {
    const options = [];
    if (sourceFilename) {
      options.push({ filename: sourceFilename, name: sourceName || sourceFilename });
    }
    (recentFiles || []).forEach((item) => {
      if (!item?.filename || item.filename === sourceFilename) return;
      options.push(item);
    });
    return options;
  }, [recentFiles, sourceFilename, sourceName]);

  return (
    <div className="app">
      <div className="content">
        <div className="column-left">
          <div className="panel toolbar">
            <button
              className="icon-only"
              onClick={handleLoadClick}
              title="Load"
              aria-label="Load"
            >
              <svg viewBox="0 0 20 20" width="16" height="16" aria-hidden="true">
                <path
                  d="M10 3v9m0 0l-3-3m3 3l3-3M4 15h12"
                  stroke="currentColor"
                  strokeWidth="2"
                  fill="none"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                />
              </svg>
            </button>
            <input
              ref={sourceFileInputRef}
              type="file"
              accept=".svg"
              style={{ display: "none" }}
              onChange={(e) => {
                const file = e.target.files?.[0];
                if (file) handleFileUpload(file);
              }}
            />
            <label className="toolbar-select" htmlFor="recent-files">
              Recent
              <select
                id="recent-files"
                value={sourceFilename || ""}
                onChange={(e) => handleRecentSelect(e.target.value)}
              >
                {recentOptions.length ? (
                  recentOptions.map((item) => (
                    <option key={item.filename} value={item.filename}>
                      {item.name || item.filename}
                    </option>
                  ))
                ) : (
                  <option value="">None</option>
                )}
              </select>
            </label>
            <button className="icon-only" onClick={exportPdf} title="Export PDF" aria-label="Export PDF">
              <svg viewBox="0 0 20 20" width="16" height="16" aria-hidden="true">
                <path
                  d="M6 3h5l3 3v11H6z"
                  stroke="currentColor"
                  strokeWidth="2"
                  fill="none"
                  strokeLinejoin="round"
                />
                <path d="M11 3v3h3" stroke="currentColor" strokeWidth="2" fill="none" />
              </svg>
            </button>
            <button
              className="icon-only"
              onClick={() => {
                setSimProgress(0);
                setSimPlaying(false);
                setShowSim(true);
              }}
              title="Simulate"
              aria-label="Simulate"
            >
              <svg viewBox="0 0 20 20" width="16" height="16" aria-hidden="true">
                <polygon points="6,4 16,10 6,16" fill="currentColor" />
              </svg>
            </button>
            <div className="toolbar-spacer" />
            <button
              className="icon-only"
              onClick={async () => {
                setPackedLoading(true);
                try {
                  let source = zoneScene || scene;
                  if (!source || !source.canvas || !source.regions || !source.zone_id) {
                    const loaded = await loadScene(false, true, true);
                    source = loaded?.zoneScene || loaded?.scene || source;
                  }
                  if (source && source.canvas && source.regions && source.zone_id) {
                    await refreshPackedFromZoneScene(source);
                  }
                } finally {
                  setPackedLoading(false);
                }
              }}
              title="Compute"
              aria-label="Compute"
            >
              <svg viewBox="0 0 20 20" width="16" height="16" aria-hidden="true">
                <path
                  d="M10 3l2 4 4 2-4 2-2 4-2-4-4-2 4-2z"
                  fill="currentColor"
                />
              </svg>
            </button>
            {exportMsg ? <div className="meta">{exportMsg}</div> : null}
            {error ? <div className="error">{error}</div> : null}
          </div>

          <div className="view-tabs-row">
            <div className="panel view-tabs">
              <button className={leftTab === 'source' ? 'active' : ''} onClick={() => setLeftTab('source')}>Source</button>
              <button className={leftTab === 'region' ? 'active' : ''} onClick={() => setLeftTab('region')}>Region</button>
              <button className={leftTab === 'zone' ? 'active' : ''} onClick={() => setLeftTab('zone')}>Zone</button>
            </div>
            <div className="view-tabs-controls">
              <label htmlFor="target-zones">
                Max Zones
                <input
                  id="target-zones"
                  type="number"
                  min="1"
                  max="999"
                  step="1"
                  value={targetZones}
                  onChange={(e) => {
                    const next = parseInt(e.target.value, 10);
                    if (!Number.isFinite(next)) return;
                    setTargetZones(Math.max(1, next));
                  }}
                />
              </label>
              <label htmlFor="pack-margin">
                Margin
                <input
                  id="pack-margin"
                  type="number"
                  min="0"
                  max="200"
                  step="1"
                  value={packMargin}
                  onChange={(e) => {
                    const next = parseFloat(e.target.value || "0");
                    if (!Number.isFinite(next)) return;
                    setPackMargin(next);
                  }}
                />
              </label>
            </div>
          </div>

          {leftTab === 'source' && (
            <div className={`left ${sceneLoading ? "is-loading" : ""}`} ref={leftRef}>
              <div className="preview-header">
                <div className="preview-title">Source (Konva)</div>
                <div className="preview-controls">
                  <button
                    className={`icon-button ${edgeMode ? "active" : ""}`}
                    title="Create Edge"
                    onClick={() => {
                      setEdgeMode((v) => !v);
                      setAddNodeMode(false);
                      setDeleteEdgeMode(false);
                      setEdgeCandidate(null);
                      setDeleteEdgeCandidate(null);
                    }}
                  >
                    <svg viewBox="0 0 20 20" width="16" height="16" aria-hidden="true">
                      <circle cx="4" cy="4" r="2" fill="currentColor" />
                      <circle cx="16" cy="16" r="2" fill="currentColor" />
                      <line x1="5.5" y1="5.5" x2="14.5" y2="14.5" stroke="currentColor" strokeWidth="2" />
                    </svg>
                  </button>
                  <button
                    className={`icon-button ${addNodeMode ? "active" : ""}`}
                    title="Add Node"
                    onClick={() => {
                      setAddNodeMode((v) => !v);
                      setEdgeMode(false);
                      setDeleteEdgeMode(false);
                      setEdgeCandidate(null);
                      setDeleteEdgeCandidate(null);
                    }}
                  >
                    <svg viewBox="0 0 20 20" width="16" height="16" aria-hidden="true">
                      <circle cx="10" cy="10" r="3" fill="currentColor" />
                      <line x1="10" y1="4" x2="10" y2="16" stroke="currentColor" strokeWidth="2" />
                      <line x1="4" y1="10" x2="16" y2="10" stroke="currentColor" strokeWidth="2" />
                    </svg>
                  </button>
                  <button
                    className={`icon-button ${deleteEdgeMode ? "active" : ""}`}
                    title="Delete Edge"
                    onClick={() => {
                      setDeleteEdgeMode((v) => !v);
                      setEdgeMode(false);
                      setAddNodeMode(false);
                      setEdgeCandidate(null);
                      setDeleteEdgeCandidate(null);
                    }}
                  >
                    <svg viewBox="0 0 20 20" width="16" height="16" aria-hidden="true">
                      <line x1="4" y1="4" x2="16" y2="16" stroke="currentColor" strokeWidth="2" />
                      <line x1="16" y1="4" x2="4" y2="16" stroke="currentColor" strokeWidth="2" />
                    </svg>
                  </button>
                  <button className="icon-button" title="Overlay" onClick={handleOverlayPick}>
                    <svg viewBox="0 0 20 20" width="16" height="16" aria-hidden="true">
                      <rect x="3" y="4" width="12" height="10" rx="1" ry="1" stroke="currentColor" strokeWidth="2" fill="none" />
                      <rect x="7" y="6" width="10" height="10" rx="1" ry="1" stroke="currentColor" strokeWidth="2" fill="none" opacity="0.7" />
                    </svg>
                  </button>
                  <input
                    ref={overlayInputRef}
                    type="file"
                    accept=".svg"
                    style={{ display: "none" }}
                    onChange={handleOverlayFileChange}
                  />
                  <label className="mini-input">
                    Overlay Fill
                    <input
                      type="color"
                      value={overlayFill}
                      onChange={(e) => {
                        const color = e.target.value;
                        setOverlayFill(color);
                        if (selectedOverlayId) updateOverlayColor(selectedOverlayId, color);
                      }}
                    />
                  </label>
                  <button
                    className="icon-button"
                    title="Download"
                    onClick={() =>
                      downloadStage(stageRef, "source-konva.svg", scene?.canvas || null)
                  }
                  >
                    {"\u2193"}
                  </button>
                </div>
              </div>
              <Stage
                width={stageSize.w}
                height={stageSize.h}
                draggable
                scaleX={mainViewScale}
                scaleY={mainViewScale}
                x={mainViewPos.x}
                y={mainViewPos.y}
                onWheel={handleMainViewWheel}
                onMouseMove={() => {
                    const stage = stageRef.current;
                    const pointer = stage.getPointerPosition();
                    if (!pointer) return;
                    const world = {
                      x: (pointer.x - mainViewPos.x) / mainViewScale,
                      y: (pointer.y - mainViewPos.y) / mainViewScale,
                    };
                    if (edgeMode) {
                      const cand = findEdgeCandidate(world);
                      setEdgeCandidate(cand);
                      setDeleteEdgeCandidate(null);
                    } else if (deleteEdgeMode) {
                      const cand = findExistingEdgeCandidate(world);
                      setDeleteEdgeCandidate(cand);
                      setEdgeCandidate(null);
                    } else {
                      setEdgeCandidate(null);
                      setDeleteEdgeCandidate(null);
                    }
                  }}
                  onMouseLeave={() => {
                    if (edgeMode) setEdgeCandidate(null);
                    if (deleteEdgeMode) setDeleteEdgeCandidate(null);
                  }}
                  onMouseDown={() => {
                    const stage = stageRef.current;
                    const pointer = stage.getPointerPosition();
                    if (!pointer) return;
                    const world = {
                      x: (pointer.x - mainViewPos.x) / mainViewScale,
                      y: (pointer.y - mainViewPos.y) / mainViewScale,
                    };
                    if (edgeMode) {
                      if (!edgeCandidate) return;
                      const key = edgeKey(edgeCandidate.a, edgeCandidate.b);
                      const segSet = new Set(segs.map(([a, b]) => edgeKey(a, b)));
                      if (segSet.has(key)) return;
                      const nextSegs = [...segs, [edgeCandidate.a, edgeCandidate.b]];
                      setSegs(nextSegs);
                      return;
                    }
                    if (deleteEdgeMode) {
                      if (!deleteEdgeCandidate) return;
                      const nextSegs = segs.filter((_, idx) => idx !== deleteEdgeCandidate.idx);
                      const pruned = pruneIsolatedNodes(nodes, nextSegs);
                      setNodes(pruned.nodes);
                      setSegs(pruned.segs);
                      return;
                    }
                    if (addNodeMode) {
                      const nextNodes = [...nodes, { id: nodes.length, x: world.x, y: world.y }];
                      let nextSegs = [...segs];
                      if (nodes.length) {
                        let nearest = 0;
                        let best = Infinity;
                        nodes.forEach((n, idx) => {
                          const d = Math.hypot(n.x - world.x, n.y - world.y);
                          if (d < best) {
                            best = d;
                            nearest = idx;
                          }
                        });
                        nextSegs.push([nextNodes.length - 1, nearest]);
                      }
                      setNodes(nextNodes);
                      setSegs(nextSegs);
                    }
                  }}
                  ref={stageRef}
                >
            <Layer>
              {scene?.canvas ? (
                <Rect
                  x={0}
                  y={0}
                  width={scene.canvas.w}
                  height={scene.canvas.h}
                  stroke="#ffffff"
                  strokeWidth={2 / mainViewScale}
                  listening={false}
                />
              ) : null}
            </Layer>
              <Layer>{nodeLayer}</Layer>
              <Layer>{borderLayer}</Layer>
              {edgeCandidate ? (
                <Layer>
                  <Line
                    points={[
                      nodes[edgeCandidate.a].x,
                      nodes[edgeCandidate.a].y,
                      nodes[edgeCandidate.b].x,
                      nodes[edgeCandidate.b].y,
                    ]}
                    stroke="#cfd6ff"
                    opacity={0.4}
                    strokeWidth={(1 / mainViewScale) * 2.5}
                    strokeScaleEnabled={false}
                  />
                </Layer>
              ) : null}
              {deleteEdgeCandidate ? (
                <Layer>
                  <Line
                    points={[
                      nodes[deleteEdgeCandidate.a].x,
                      nodes[deleteEdgeCandidate.a].y,
                      nodes[deleteEdgeCandidate.b].x,
                      nodes[deleteEdgeCandidate.b].y,
                    ]}
                    stroke="#ff3b30"
                    opacity={0.6}
                    strokeWidth={(1 / mainViewScale) * 2.5}
                    strokeScaleEnabled={false}
                  />
                </Layer>
              ) : null}
              <Layer name="source-overlay">
                {overlayItems.map((item) =>
                  item.img ? (
                    <Image
                      key={item.id}
                      image={item.img}
                      x={item.x}
                      y={item.y}
                      width={item.width}
                      height={item.height}
                      offsetX={item.width / 2}
                      offsetY={item.height / 2}
                      scaleX={item.scaleX}
                      scaleY={item.scaleY}
                      rotation={item.rotation}
                      draggable={!edgeMode && !deleteEdgeMode && !addNodeMode}
                      onClick={() => setSelectedOverlayId(item.id)}
                      onTap={() => setSelectedOverlayId(item.id)}
                      onDragEnd={(e) => {
                        const nx = e.target.x();
                        const ny = e.target.y();
                        const zid = findZoneAtPoint({ x: nx, y: ny });
                        const next = overlayItems.map((o) =>
                          o.id === item.id ? { ...o, x: nx, y: ny, zid } : o
                        );
                        setOverlayItems(next);
                      }}
                      onTransformEnd={() => {
                        const node = overlayNodeRefs.current[item.id];
                        if (!node) return;
                        const scaleX = node.scaleX();
                        const scaleY = node.scaleY();
                        const rotation = node.rotation();
                        const nx = node.x();
                        const ny = node.y();
                        node.scaleX(1);
                        node.scaleY(1);
                        const next = overlayItems.map((o) =>
                          o.id === item.id
                            ? {
                                ...o,
                                x: nx,
                                y: ny,
                                rotation,
                                scaleX: o.scaleX * scaleX,
                                scaleY: o.scaleY * scaleY,
                              }
                            : o
                        );
                        setOverlayItems(next);
                      }}
                      ref={(node) => {
                        if (node) overlayNodeRefs.current[item.id] = node;
                      }}
                    />
                  ) : null
                )}
                <Transformer
                  ref={overlayTransformerRef}
                  rotateEnabled
                  enabledAnchors={[
                    "top-left",
                    "top-right",
                    "bottom-left",
                    "bottom-right",
                  ]}
                  boundBoxFunc={(oldBox, newBox) => {
                    if (newBox.width < 10 || newBox.height < 10) return oldBox;
                    return newBox;
                  }}
                />
              </Layer>
            <Layer>
              {nodes.map((n) => (
                  <Circle
                    key={`n-${n.id}`}
                    x={n.x}
                    y={n.y}
                    radius={3 / mainViewScale}
                    fill="red"
                    strokeScaleEnabled={false}
                    draggable={!edgeMode && !deleteEdgeMode && !addNodeMode}
                    onDragMove={(e) => {
                    const next = nodes.map((p) =>
                      p.id === n.id ? { ...p, x: e.target.x(), y: e.target.y() } : p
                    );
                    setNodes(next);
                  }}
                    onDragEnd={(e) => {
                      const next = nodes.map((p) =>
                        p.id === n.id ? { ...p, x: e.target.x(), y: e.target.y() } : p
                      );
                      const merged = mergeNodesIfClose(next, segs, n.id, snap);
                      setNodes(merged.nodes);
                      setSegs(merged.segs);
                    }}
                  />
              ))}
            </Layer>
              </Stage>
              {sceneLoading ? <div className="loading-overlay">Loading...</div> : null}
              {renderLeftDebug()}
            </div>
          )}

          {leftTab === 'region' && (
            <div className={`preview half ${sceneLoading ? "is-loading" : ""}`} ref={region2WrapRef}>
              <div className="preview-header">
                <div className="preview-title">Region (Konva)</div>
                <div className="preview-controls">
                  <button
                    className="btn"
                    onClick={() => {
                      saveSvg(nodes, segs, overlayItems).then(async () => {
                        await saveState();
                        await loadScene(true, false, true);
                      });
                    }}
                  >
                    Save
                  </button>
                  <button
                    className="icon-button"
                    title="Download"
                    onClick={() =>
                      downloadStage(region2Ref, "region-konva.svg", scene?.canvas || null)
                    }
                  >
                    {"\u2193"}
                  </button>
                </div>
              </div>
              {scene ? (
                <Stage
                  width={region2StageSize.w}
                  height={region2StageSize.h}
                  draggable
                  scaleX={mainViewScale}
                  scaleY={mainViewScale}
                  x={mainViewPos.x}
                  y={mainViewPos.y}
                  onWheel={handleMainViewWheel}
                  ref={region2Ref}
                >
                  <Layer>
                    {scene?.canvas ? (
                      <Rect
                        x={0}
                        y={0}
                        width={scene.canvas.w}
                        height={scene.canvas.h}
                        stroke="#ffffff"
                        strokeWidth={2 / mainViewScale}
                        listening={false}
                      />
                    ) : null}
                  </Layer>
                  <Layer>
                    {scene.regions.map((poly, idx) => (
                      <Line
                        key={`r2-${idx}`}
                        points={toPoints(poly)}
                        closed
                        stroke="#f5f6ff"
                        fill="#bbb"
                        strokeWidth={1 / mainViewScale}
                        strokeScaleEnabled={false}
                      />
                    ))}
                  </Layer>
                </Stage>
              ) : null}
              {sceneLoading ? <div className="loading-overlay">Loading...</div> : null}
              {renderLeftDebug()}
            </div>
          )}

          {leftTab === 'zone' && (
            <div className={`preview half ${sceneLoading ? "is-loading" : ""}`} ref={zoneWrapRef}>
              <div className="preview-header">
              <div className="preview-title">Zone (Konva)</div>
              <div className="preview-controls">
                <button
                  className="icon-button"
                  title="Download"
                    onClick={() =>
                      downloadStage(zoneRef, "zone-konva.svg", scene?.canvas || null)
                    }
                  >
                    {"\u2193"}
                  </button>
                </div>
              </div>
              {zoneScene || scene ? (
                <Stage
                  width={zoneStageSize.w}
                  height={zoneStageSize.h}
                  draggable
                  scaleX={mainViewScale}
                  scaleY={mainViewScale}
                  x={mainViewPos.x}
                  y={mainViewPos.y}
                  onWheel={handleMainViewWheel}
                  ref={zoneRef}
                >
                  <Layer>
              {zoneScene?.canvas || scene?.canvas ? (
                  <Rect
                    x={0}
                    y={0}
                    width={(zoneScene || scene).canvas.w}
                    height={(zoneScene || scene).canvas.h}
                    stroke="#ffffff"
                    strokeWidth={2 / mainViewScale}
                    listening={false}
                  />
                ) : null}
              </Layer>
              <Layer name="zone-image" visible={showImages}>
                {(zoneScene || scene).region_colors
                  ? (zoneScene || scene).regions.map((poly, idx) => (
                      <Line
                        key={`zf-${idx}`}
                        points={toPoints(poly)}
                        closed
                        fill={(zoneScene || scene).region_colors[idx]}
                        strokeScaleEnabled={false}
                        onClick={(e) => handleZoneRegionClick(idx, e)}
                        onTap={(e) => handleZoneRegionClick(idx, e)}
                      />
                    ))
                  : null}
              </Layer>
              <Layer name="zone-overlay">
                {overlayItems.map((item) =>
                  item?.img ? (
                    <Image
                      key={`zo-${item.id}`}
                      image={item.img}
                          x={item.x}
                          y={item.y}
                          width={item.width}
                          height={item.height}
                          offsetX={item.width / 2}
                          offsetY={item.height / 2}
                          scaleX={item.scaleX}
                          scaleY={item.scaleY}
                          rotation={item.rotation}
                          listening={false}
                        />
                      ) : null
                    )}
                  </Layer>
                  <Layer name="zone-stroke">
                    {Object.entries((zoneScene || scene).zone_boundaries || {}).flatMap(
                      ([zid, paths]) =>
                      paths.map((p, i) => (
                        <Line
                          key={`zb2-${zid}-${i}`}
                          points={toPoints(p)}
                          stroke={String(zid) === String(selectedZoneId) ? "#ff3b30" : "#f5f6ff"}
                          strokeWidth={String(zid) === String(selectedZoneId) ? 6 : 2}
                          strokeScaleEnabled={false}
                        />
                      ))
                    )}
                  </Layer>
                  <Layer name="zone-label" visible={showLabels}>
                    {Object.entries((zoneScene || scene).zone_labels || {}).map(([zid, lbl]) => {
                      const center = zoneLabelCenters[String(zid)];
                      const lx = center?.x ?? lbl.x;
                      const ly = center?.y ?? lbl.y;
                      const selectedShuffle =
                        (zoneScene || scene)?.zone_label_map?.[selectedZoneId] ??
                        (zoneScene || scene)?.zone_label_map?.[parseInt(selectedZoneId, 10)];
                      const targetLabel = selectedShuffle != null ? selectedShuffle : selectedZoneId;
                      const isSelected = String(lbl.label) === String(targetLabel);
                      const size = Math.max(labelFontSize / mainViewScale, 6 / mainViewScale);
                      const metrics = measureText(lbl.label, size, labelFontFamily);
                        return (
                          <Text
                            key={`zl-${zid}`}
                            x={lx}
                            y={ly}
                            text={`${lbl.label}`}
                            fill={isSelected ? "#ff3b30" : "#ffffff"}
                            fontSize={size}
                            fontFamily={labelFontFamily}
                            align="center"
                            verticalAlign="middle"
                            offsetX={metrics.width / 2}
                            offsetY={metrics.height / 2}
                            listening
                            hitStrokeWidth={10 / mainViewScale}
                            onClick={() => {
                              setSelectedZoneId(String(zid));
                            }}
                            onTap={() => {
                              setSelectedZoneId(String(zid));
                            }}
                            onMouseDown={() => {
                              setSelectedZoneId(String(zid));
                            }}
                            onTouchStart={() => {
                              setSelectedZoneId(String(zid));
                            }}
                          />
                        );
                    })}
                  </Layer>
                </Stage>
              ) : null}
              {sceneLoading ? <div className="loading-overlay">Loading...</div> : null}
              {renderLeftDebug()}
            </div>
          )}
        </div>
        <div className="right">
          <div className="panel view-tabs">
            <button
              className={rightTab === "packed" ? "active" : ""}
              onClick={() => setRightTab("packed")}
            >
              Packed
            </button>
            <button
              className={rightTab === "box" ? "active" : ""}
              onClick={() => setRightTab("box")}
            >
              Box
            </button>
          </div>
          <div className={`preview region-stage ${sceneLoading || packedLoading ? "is-loading" : ""}`} ref={regionWrapRef} style={{ height: '100%'}}>
            <div className="preview-header">
              <div className="preview-title">
                {rightTab === "packed" ? "Packed (Konva)" : "Packed (Box)"}
              </div>
              <div className="preview-controls">
                <label className="checkbox">
                  <input
                    type="checkbox"
                    checked={showImages}
                    onChange={(e) => {
                      setShowImages(e.target.checked);
                    }}
                  />
                  Image
                </label>
                <label className="checkbox">
                  <input
                    type="checkbox"
                    checked={showStroke}
                    onChange={(e) => {
                      setShowStroke(e.target.checked);
                    }}
                  />
                  Stroke
                </label>
                <label className="checkbox">
                  <input
                    type="checkbox"
                    checked={showLabels}
                    onChange={(e) => {
                      setShowLabels(e.target.checked);
                    }}
                  />
                  Label
                </label>
                <label className="mini-input">
                  Font
                  <select
                    value={labelFontFamily}
                    onChange={(e) => setLabelFontFamily(e.target.value)}
                  >
                    <option value="Arial">Arial</option>
                    <option value="Helvetica">Helvetica</option>
                    <option value="Verdana">Verdana</option>
                    <option value="Tahoma">Tahoma</option>
                    <option value="Georgia">Georgia</option>
                    <option value="Times New Roman">Times New Roman</option>
                    <option value="Courier New">Courier New</option>
                  </select>
                </label>
                <label className="mini-input">
                  Size
                  <input
                    type="number"
                    min="4"
                    max="64"
                    value={labelFontSize}
                    onChange={(e) => setLabelFontSize(parseFloat(e.target.value || "12"))}
                  />
                </label>
                <button
                  className="icon-button"
                  title="Download"
                  onClick={() =>
                    downloadStage(
                      regionRef,
                      rightTab === "box" ? "packed-bbox-konva.svg" : "packed-konva.svg",
                      scene?.canvas ? { w: scene.canvas.w, h: scene.canvas.h } : null
                    )
                  }
                >
                  {"\u2193"}
                </button>
              </div>
            </div>
            {packedSource ? (
              <Stage
                width={regionStageSize.w}
                height={regionStageSize.h}
                  draggable
                  scaleX={regionScale}
                  scaleY={regionScale}
                  x={regionPos.x}
                  y={regionPos.y}
                  onWheel={handleRegionWheel}
                ref={regionRef}
              >
                <Layer>
                  {packedSource?.canvas ? (
                    <>
                      <Rect
                        x={0}
                        y={0}
                        width={packedSource.canvas.w}
                        height={packedSource.canvas.h}
                        stroke="#ffffff"
                        strokeWidth={2 / regionScale}
                        listening={false}
                      />
                    </>
                  ) : null}
                </Layer>
                {rightTab === "packed" ? (
                <Layer name="packed-image" visible={showImages}>
                  <>
                    <Group
                      x={(packedSource?.canvas?.w || 0) / 2}
                      y={(packedSource?.canvas?.h || 0) / 2}
                      offsetX={(packedSource?.canvas?.w || 0) / 2}
                      offsetY={(packedSource?.canvas?.h || 0) / 2}
                    >
                      {packedFillPaths.map((p, idx) => (
                        <Path
                          key={`fill-path-${idx}`}
                          data={p.d}
                          fill={p.fill}
                          strokeWidth={0}
                          listening={false}
                        />
                      ))}
                      {packedBleedPaths.map((p, idx) => (
                        <Path
                          key={`bleed-path-${idx}`}
                          data={p.d}
                          fill={p.fill}
                          strokeWidth={0}
                          listening={false}
                        />
                      ))}
                    </Group>
                    <Group
                      x={(packedSource?.canvas?.w || 0) / 2 + (packedSource?.canvas?.w || 0) + 40}
                      y={(packedSource?.canvas?.h || 0) / 2}
                      offsetX={(packedSource?.canvas?.w || 0) / 2}
                      offsetY={(packedSource?.canvas?.h || 0) / 2}
                    >
                      {packedFillPaths2.map((p, idx) => (
                        <Path
                          key={`fill-path-2-${idx}`}
                          data={p.d}
                          fill={p.fill}
                          strokeWidth={0}
                          listening={false}
                        />
                      ))}
                      {packedBleedPaths2.map((p, idx) => (
                        <Path
                          key={`bleed-path-2-${idx}`}
                          data={p.d}
                          fill={p.fill}
                          strokeWidth={0}
                          listening={false}
                        />
                      ))}
                    </Group>
                  </>
                </Layer>
                ) : null}
                {rightTab === "packed" && packedLabelSnappedAll.length ? (
                <Layer name="packed-label-snapped">
                  {packedLabelSnappedAll.map((lbl) => {
                    const size = Math.max(labelFontSize / regionScale, 6 / regionScale);
                    const metrics = measureText(lbl.label, size, labelFontFamily);
                    return (
                      <Text
                        key={`psnap-${lbl.zid}`}
                        x={lbl.x}
                        y={lbl.y}
                        text={lbl.label}
                        fill="#ffffff"
                        stroke="rgba(0,0,0,0.5)"
                        strokeWidth={1 / regionScale}
                        fontSize={size}
                        fontFamily={labelFontFamily}
                        align="center"
                        verticalAlign="middle"
                        offsetX={metrics.width / 2}
                        offsetY={metrics.height / 2}
                        listening={false}
                      />
                    );
                  })}
                </Layer>
                ) : null}
                {rightTab === "packed" ? (
                <Layer name="packed-overlay">
                  {overlayItems.map((item) => {
                    if (!item?.img || item.zid == null) return null;
                    const packed = transformOverlayToPacked(item);
                    const xOffset = 0;
                    return (
                      <Image
                        key={`po-${item.id}`}
                        image={packed.img}
                        x={packed.x + xOffset}
                        y={packed.y}
                        width={packed.width}
                        height={packed.height}
                        offsetX={packed.width / 2}
                        offsetY={packed.height / 2}
                        scaleX={packed.scaleX}
                        scaleY={packed.scaleY}
                        rotation={packed.rotation}
                        listening={false}
                      />
                    );
                  })}
                </Layer>
                ) : null}
                {rightTab === "packed" ? (
                <Layer name="packed-stroke" visible={showStroke}>
                  {Object.entries(packedSource.zone_boundaries || {}).flatMap(([zid, paths]) => {
                    const xOffset = 0;
                      return (paths || []).map((p, i) => {
                        const shift =
                          packedSource.zone_shift?.[zid] ||
                          packedSource.zone_shift?.[parseInt(zid, 10)];
                        if (!shift) return null;
                        const rot =
                          packedSource.zone_rot?.[zid] ??
                          packedSource.zone_rot?.[parseInt(zid, 10)] ??
                          0;
                        const center =
                          packedSource.zone_center?.[zid] ||
                          packedSource.zone_center?.[parseInt(zid, 10)] ||
                          [0, 0];
                        const tpts = transformPath(p, shift, rot, center);
                        const isSelected = String(zid) === String(selectedZoneId);
                        return (
                          <Line
                            key={`pz-outline-${zid}-${i}`}
                            points={toPoints(offsetPoints(tpts, xOffset, 0))}
                            stroke={isSelected ? "#ff3b30" : "#f5f6ff"}
                            strokeWidth={isSelected ? 3 : 1}
                            strokeScaleEnabled={false}
                            listening={false}
                          />
                        );
                      });
                  })}
                </Layer>
                ) : null}
                {rightTab === "box" ? (
                <Layer name="packed-box-polys">
                  {(packedSource.zone_pack_polys && packedSource.zone_pack_polys.length
                    ? packedSource.zone_pack_polys.map((poly, idx) => {
                        const zid = packedSource.zone_order?.[idx];
                        if (zid == null) return null;
                        const shift =
                          packedSource.zone_shift?.[zid] ||
                          packedSource.zone_shift?.[parseInt(zid, 10)];
                        if (!shift) return null;
                        const rot =
                          packedSource.zone_rot?.[zid] ??
                          packedSource.zone_rot?.[parseInt(zid, 10)] ??
                          0;
                        const center =
                          packedSource.zone_center?.[zid] ||
                          packedSource.zone_center?.[parseInt(zid, 10)] ||
                          [0, 0];
                        const tpts = transformPath(poly, shift, rot, center);
                        const xOffset = 0;
                        return (
                          <Line
                            key={`pb-zone-${zid}`}
                            points={toPoints(offsetPoints(tpts, xOffset, 0))}
                            closed
                            fill="rgba(255,255,255,0.06)"
                            stroke={showStroke ? "#f5f6ff" : "transparent"}
                            strokeWidth={1 / regionScale}
                            strokeScaleEnabled={false}
                            listening={false}
                          />
                        );
                      })
                    : (packedSource.regions || []).map((poly, idx) => {
                        const zid = packedSource.zone_id?.[idx];
                        const shift =
                          packedSource.zone_shift?.[zid] ||
                          packedSource.zone_shift?.[parseInt(zid, 10)];
                        if (!shift) return null;
                        const rot =
                          packedSource.zone_rot?.[zid] ??
                          packedSource.zone_rot?.[parseInt(zid, 10)] ??
                          0;
                        const center =
                          packedSource.zone_center?.[zid] ||
                          packedSource.zone_center?.[parseInt(zid, 10)] ||
                          [0, 0];
                        const tpts = transformPath(poly, shift, rot, center);
                        const xOffset = 0;
                        const fill = packedSource.region_colors?.[idx];
                        return (
                          <Line
                            key={`pb-poly-${idx}`}
                            points={toPoints(offsetPoints(tpts, xOffset, 0))}
                            closed
                            fill={showImages ? fill : "transparent"}
                            stroke={showStroke ? "#f5f6ff" : "transparent"}
                            strokeWidth={1 / regionScale}
                            strokeScaleEnabled={false}
                            listening={false}
                          />
                        );
                      }))}
                </Layer>
                ) : null}
                {rightTab === "packed" ? (
                <Layer name="packed-hit">
                  {Object.entries(packedSource.zone_boundaries || {}).flatMap(([zid, paths]) => {
                    const xOffset = 0;
                    return (paths || []).map((p, i) => {
                      const shift =
                        packedSource.zone_shift?.[zid] ||
                        packedSource.zone_shift?.[parseInt(zid, 10)];
                      if (!shift) return null;
                      const rot =
                        packedSource.zone_rot?.[zid] ??
                        packedSource.zone_rot?.[parseInt(zid, 10)] ??
                        0;
                      const center =
                        packedSource.zone_center?.[zid] ||
                        packedSource.zone_center?.[parseInt(zid, 10)] ||
                        [0, 0];
                      const tpts = transformPath(p, shift, rot, center);
                      return (
                        <Line
                          key={`pz-hit-${zid}-${i}`}
                          points={toPoints(offsetPoints(tpts, xOffset, 0))}
                          stroke="rgba(0,0,0,0)"
                          strokeWidth={8 / regionScale}
                          strokeScaleEnabled={false}
                          onClick={() => handlePackedZoneClick(zid)}
                        />
                      );
                      });
                  })}
                </Layer>
                ) : null}
                {rightTab === "box" ? (
                <Layer name="packed-bbox">
                  {packedEmptyCellsDerived.map((cell, idx) => (
                    <Circle
                      key={`pcell-${idx}`}
                      x={cell[0]}
                      y={cell[1]}
                      radius={2.2 / regionScale}
                      stroke="#00c2ff"
                      strokeWidth={1 / regionScale}
                      fill="rgba(0,194,255,0.12)"
                      listening={false}
                    />
                  ))}
                  {packedBoxData.map((box) => {
                    const w = Math.max(0, box.maxx - box.minx);
                    const h = Math.max(0, box.maxy - box.miny);
                    const size = Math.max(10 / regionScale, 6 / regionScale);
                    const metrics = measureText(box.label, size, labelFontFamily);
                    return (
                      <React.Fragment key={`pb-${box.zid}`}>
                        {showStroke ? (
                          <Rect
                            x={box.minx + box.xOffset}
                            y={box.miny}
                            width={w}
                            height={h}
                            stroke="#00ff7f"
                            strokeWidth={1 / regionScale}
                            listening={false}
                          />
                        ) : null}
                        {showLabels ? (
                          <Text
                            x={box.minx + box.xOffset + 2 / regionScale}
                            y={box.miny + 2 / regionScale}
                            text={`${box.label}`}
                            fill="#00ff7f"
                            fontSize={size}
                            fontFamily={labelFontFamily}
                            align="left"
                            verticalAlign="top"
                            offsetX={0}
                            offsetY={0}
                            listening={false}
                          />
                        ) : null}
                      </React.Fragment>
                    );
                  })}
                </Layer>
                ) : null}
              </Stage>
            ) : null}
            {sceneLoading || packedLoading ? <div className="loading-overlay">Loading...</div> : null}
            {packedBleedError ? <div className="error">{packedBleedError}</div> : null}
            {packedBleedError2 ? <div className="error">{packedBleedError2}</div> : null}
          </div>
        </div>
      </div>
      {exportPdfLoading || exportPdfInfo ? (
        <div className="modal-backdrop">
          <div className="modal">
            <div className="modal-title">
              {exportPdfLoading ? "Creating PDF..." : "Successful created PDF !"}
            </div>
            {!exportPdfLoading && exportPdfInfo ? (
              <div className="modal-actions">
                <button
                  className="btn ghost"
                  onClick={() => setExportPdfInfo(null)}
                >
                  Cancel
                </button>
                <button
                  className="btn"
                  onClick={() => {
                    window.location = `/api/download_pdf?name=${encodeURIComponent(
                      exportPdfInfo.name
                    )}`;
                    setExportPdfInfo(null);
                  }}
                >
                  Download PDF
                </button>
                {exportHtmlInfo.map((name) => (
                  <button
                    key={name}
                    className="btn"
                    onClick={() => {
                      window.location = `/api/download_html?name=${encodeURIComponent(name)}`;
                    }}
                  >
                    Download HTML
                  </button>
                ))}
              </div>
            ) : null}
          </div>
        </div>
      ) : null}
      {showSim ? (
        <div className="modal-backdrop">
          <div className="modal sim-modal">
            <button className="modal-close" onClick={() => setShowSim(false)}>
              X
            </button>
            <div className="modal-title">Simulate</div>
            <div className="sim-status">
              {simActiveLabel ? `Moving index: ${simActiveLabel}` : "Moving index: -"}
            </div>
            <div className="sim-controls">
              <button className="icon-button" onClick={handleSimPlayToggle}>
                {simPlaying ? (
                  <svg viewBox="0 0 20 20" width="16" height="16" aria-hidden="true">
                    <rect x="4" y="3" width="4" height="14" fill="currentColor" />
                    <rect x="12" y="3" width="4" height="14" fill="currentColor" />
                  </svg>
                ) : (
                  <svg viewBox="0 0 20 20" width="16" height="16" aria-hidden="true">
                    <polygon points="6,4 16,10 6,16" fill="currentColor" />
                  </svg>
                )}
              </button>
              <input
                type="range"
                min="0"
                max="1"
                step="0.001"
                value={simProgress}
                onChange={(e) => setSimProgress(parseFloat(e.target.value))}
              />
              <button className="btn ghost" onClick={handleSimHtmlDownload}>
                Download HTML
              </button>
              <button
                className="btn"
                onClick={handleSimVideoDownload}
                disabled={simVideoLoading}
              >
                {simVideoLoading ? "Creating..." : "Download GIF"}
              </button>
            </div>
            <div className="sim-body" ref={simWrapRef}>
              {simStage}
            </div>
          </div>
        </div>
      ) : null}
    </div>
  );
}
